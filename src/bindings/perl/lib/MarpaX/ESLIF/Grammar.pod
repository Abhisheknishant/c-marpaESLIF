=head1 DESCRIPTION

MarpaX::ESLIF::Grammar is the second step after getting a MarpaX::ESLIF instance.

=head1 SYNOPSIS

  use MarpaX::ESLIF;
  my $eslif = MarpaX::ESLIF->new();
  my $data = do { local $/; <DATA> };
  my $eslifGrammar = MarpaX::ESLIF::Grammar->new($eslif, $data);

  __DATA__
  #
  # This is an example of a calculator grammar
  #
  :start   ::= Expression
  :default ::=             action        => do_op
                           symbol-action => do_symbol
                           free-action   => do_free     # Supported but useless
  :desc    ::= 'Calculator'
  :discard ::= whitespaces event  => discard_whitespaces$
  :discard ::= comment     event  => discard_comment$

  event ^Number = predicted Number
  event Number$ = completed Number
  Number   ::= NUMBER   action => ::shift

  event Expression$ = completed Expression
  event ^Expression = predicted Expression
  Expression ::=
      Number                                           action => do_int
      | '(' Expression ')'              assoc => group action => ::copy[1]
     ||     Expression '**' Expression  assoc => right
     ||     Expression  '*' Expression
      |     Expression  '/' Expression
     ||     Expression  '+' Expression
      |     Expression  '-' Expression

  whitespaces ::= WHITESPACES
  comment ::= /(?:(?:(?:\/\/)(?:[^\n]*)(?:\n|\z))|(?:(?:\/\*)(?:(?:[^\*]+|\*(?!\/))*)(?:\*\/)))/u

  :lexeme ::= NUMBER pause => before event => ^NUMBER
  :lexeme ::= NUMBER pause => after  event => NUMBER$

  :desc      ~ 'Calculator Tokens'
  NUMBER     ~ /[\d]+/   name => 'NUMBER Lexeme'
  WHITESPACES ~ [\s]+    name => 'WHITESPACES Lexeme'

As many grammars as wanted can be created using the same MarpaX::ESLIF parent. After creating a MarpaX::ESLIF::Grammar instance, the user can use the C<parse()> method to have an immediate parse value, or create a L<MarpaX::ESLIF::Recognizer> instance to control the parse.

=head1 METHODS

=head2 MarpaX::ESLIF::Grammar->new($eslif, $grammar, $encoding)

   my $eslifGrammar = MarpaX::ESLIF::Grammar->new($eslif, $data);

Returns a grammar instance, noted C<$self> later. Parameters are:

=over

=item C<$eslif>

MarpaX::ESLIF object instance. Required.

=item C<$grammar>

A scalar containing the grammar. Required.

=item C<$encoding>

A scalar containing the grammar encoding. Optional.

Encoding will always be guessed if not given.

=back

=head2 $self->ngrammar()

  printf "Number of sub-grammars: %d\n", $self->ngrammar;

Return the number of sub-grammars.

A grammar can have multiple I<sub-grammars>, identified by a level. Internally this is a I<sparse> array of grammars, and it is legal that a level is not defined.

=head2 $self->currentLevel()

  printf "Current indice: %d\n", $self->currentLevel;

Return the current level, which is always the first indice that have a defined sub-grammar.

=head2 $self->currentDescription()

  printf "Current description: %s\n", $self->currentDescription;

Return the description of the current level, with the same encoding as found in the grammar. This correspong to the C<:desc> meta-symbol in a grammar.

=head2 $self->descriptionByLevel($level)

  printf "Level 1 description: %s\n", $self->descriptionByLevel(1);

Return the description of the grammar at indice C<$level>, with the same encoding as found in the grammar.

=head2 $self->currentRuleIds

  printf "Current Rule Ids: %s\n", join(' ', @{$self->currentRuleIds});

Return the list of rule identifiers of the current grammar, as a reference to an array of integers.

I<Rule identifiers are integers that uniquely identify a rule>.

=head2 $self->ruleIdsByLevel($level)

  printf "Level 1 Rule Ids: %s\n", join(' ', @{$self->ruleIdsByLevel(1)});

Return the list of rule identifiers at indice C<$level>, as a reference to an array of integers.

=head2 $self->ruleDisplay($ruleId)

  printf "Rules names:\n\t%s\n", join("\n\t", map { $self->ruleDisplay($_) } @{$self->currentRuleIds});

Return the name of a rule identified by its rule ID C<$ruleId>.

=head2 $self->ruleShow($ruleId)

  printf "Rules shows:\n\t%s\n", join("\n\t", map { $self->ruleShow($_) } @{$self->currentRuleIds});

Return the description of a rule identified by its rule ID C<$ruleId>.

=head2 $self->ruleDisplayByLevel($level, $ruleId)

  printf "Level 1 Rule names 1:\n\t%s\n", join("\n\t", map { $self->ruleDisplayByLevel(1, $_) } @{$self->ruleIdsByLevel(1)});

Return the name of a rule at a specificed indice C<$level> identified by its rule ID C<$ruleId>. This correspond to the C<name> adverb, if present, else a default naming applies.

=head2 $self->ruleShowByLevel($level, $ruleId)

  printf "Level 1 Rules shows:\n\t%s\n", join("\n\t", map { $self->ruleShowByLevel(1, $_) } @{$self->ruleIdsByLevel(1)});

Return the description of a rule at a specified indice C<$level>, identified by its rule ID C<$ruleId>.

=head2 $self->show()

  printf "Description of current grammar: %s\n", $self->show();

Return the description of current grammar.

=head2 $self->showByLevel($level)

  printf "Level 1 grammar description: %s\n", $self->showByLevel(1);

Return the description of the grammar at indice C<$level>.

=head2 $self->parse($recognizerInterface, $valueInterface)

  my $recognizerInterface = My::Recognizer::Interface->new();
  my $valueInterface      = My::Value::Interface->new();
  if ($self->parse($recognizerInterface, $valueInterface)) {
    printf "Parse result: %s\n", $valueInterface->getResult;
  }

Short version of input validation and valuation, that will never give back control to the user until the end or a failure. No event is possible when using this method. If this method returns true, then it is guaranteed that the result is in C<$valueInterface->getResult()>.

Please refer to L<MarpaX::ESLIF::Recognizer::Interface> and L<MarpaX::ESLIF::Value::Interface> for the C<$recognizerInterface> and C<$valueInterface> required parameters.

=head1 SEE ALSO

L<MarpaX::ESLIF::Recognizer::Interface>, L<MarpaX::ESLIF::Recognizer::Interface>, L<MarpaX::ESLIF::Value::Interface>

=cut
