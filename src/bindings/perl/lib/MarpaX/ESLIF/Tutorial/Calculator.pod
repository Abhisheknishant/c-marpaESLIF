# PODNAME: MarpaX::ESLIF::Tutorial::Calculator

# ABSTRACT: MarpaX::ESLIF Calculator Tutorial

=head1 DESCRIPTION

This documentation is giving a tutorial with a calculator as example. The reader might want first to read the L<MarpaX::ESLIF::BNF> specification.

=head2 STARTUP

First we get an ESLIF instance, we use the L<Log::Any::Adapter::Stderr> implementation for logging:

  package main;
  use strict;
  use diagnostics;
  use Log::Any qw/$log/;
  use Log::Any::Adapter qw/Stderr/;
  use MarpaX::ESLIF;

  my $eslif = MarpaX::ESLIF->new($log);

=head2 Grammar v1

Grammar will support parenthesis, and the C<**>, C<*>, C</>, C<+>, C<-> operators:

  my $grammar_v1 = q{
  Expression ::=
      /[\d]+/
      | '(' Expression ')'              assoc => group
     ||     Expression '**' Expression  assoc => right
     ||     Expression  '*' Expression
      |     Expression  '/' Expression
     ||     Expression  '+' Expression
      |     Expression  '-' Expression
  };

Compiling the grammar is done with:

  my $eslifGrammar = MarpaX::ESLIF::Grammar->new($eslif, $grammar_v1);

The C<::=> mean this is the top-level grammar. It could have be writen as C<:[0]:=>.

The C<||> loosen separator is a shortcut for grouping rules, Together with the associativity adverbs, the grammar listed upper is stricly equivalent to this traditional BNF form:

  Expression   ::= Expression_0
  Expression_0 ::= Expression_1
  Expression_1 ::= Expression_2
  Expression_2 ::= Expression_3
  Expression_3 ::= /[\d]+/
  Expression_3 ::= '(' Expression_0 ')'
  Expression_2 ::= Expression_3 '**' Expression_2
  Expression_1 ::= Expression_1 '*' Expression_2
  Expression_1 ::= Expression_1 '/' Expression_2
  Expression_0 ::= Expression_0 '+' Expression_1
  Expression_0 ::= Expression_0 '-' Expression_1

With I<no associativity>, this would have been equivalent to:

  Expression   ::= Expression_0
  Expression_0 ::= Expression_1
  Expression_1 ::= Expression_2
  Expression_2 ::= Expression_3
  Expression_3 ::= /[\d]+/
  Expression_3 ::= '(' Expression_3 ')'
  Expression_2 ::= Expression_2 '**' Expression_3
  Expression_1 ::= Expression_1 '*' Expression_2
  Expression_1 ::= Expression_1 '/' Expression_2
  Expression_0 ::= Expression_0 '+' Expression_1
  Expression_0 ::= Expression_0 '-' Expression_1

You can see the impact of group associativity in the C<Expression_3> rule, and the impact of right associativity in the C<Expression_2> rule.

Since internally, a pure BNF implementation is in use, the use of the C<||> loosen operator is indeed forcing the engine to act as if you would have writen in traditional BNF, this can be seen by asking for a dump of the grammar:

  #print $eslifGrammar->show;

One can already try to parse some input. Neverthless, to do so, MarpaX::ESLIF imposes to have a I<recognizer> and a I<valuator> instances:

=over

=item Recognizer interface

A recognizer must provide the following methods: C<read>, C<isEof>, C<isCharacterStream>, C<encoding>, C<data>, C<isWithDisableThreshold>, C<isWithExhaustion> and C<isWithNewline>. We will instanciate a recognizer for a string;

  package MyRecognizer;
  use strict;
  use diagnostics;
  #
  # Constructor
  #
  sub new {
    my ($pkg, $string) = @_;
    open my $fh, "<", \$string;
    bless { data => undef, fh => $fh }, $pkg
  }

C<read> returns a true value if data was read, C<isEof> returns a true value if EOF is reached, C<isCharacterStream> returns a true value if this the last data is composed of characters, C<encoding> return the encoding if known, C<data> returns the data, C<isWithDisableThreshold> switches off a hardcoded internal warning when grammar seems to have problems -; C<isWithExhaustion> enables exhaustion event and C<isWithNewline> enables newline counting for error reporting:

  #
  # Required methods
  #
  sub read                   {
                               my ($self) = @_;   # read data
                               defined($self->{data} = readline($self->{fh}))
                             }
  sub isEof                  {  eof shift->{fh} } # End of data ?
  sub isCharacterStream      {                1 } # Character stream ?
  sub encoding               {                  } # Encoding ?
  sub data                   {    shift->{data} } # data
  sub isWithDisableThreshold {                0 } # Disable threshold warning ?
  sub isWithExhaustion       {                0 } # Exhaustion event ?
  sub isWithNewline          {                1 } # Newline count ?

=item Valuator interface

A valuator must be an object that can do: C<isWithHighRankOnly>, C<isWithOrderByRank>, C<isWithAmbiguous>, C<isWithNull>, C<maxParses>, C<getResult> and C<setResult>:

  package MyValue;
  use strict;
  use diagnostics;
  #
  # Constructor
  #
  sub new { bless { result => undef}, shift }

C<isWithHighRankOnly> select only rules that have the highest eventual C<rank> adverb, C<isWithOrderByRank> orders by rank, C<isWithAmbiguous> allows ambiguous parse tree value (i.e. there is more than one value), C<isWithNull> allows a null parse, C<maxParses> gives the maximum number of wanted parse tree values (C<0> means unlimited), and for every value iteration, there are a getters and a setter on the result: C<getResult> and C<setResult>, respectively.

  #
  # Required methods
  #
  sub isWithHighRankOnly { 1 }  # When there is the rank adverb: highest ranks only ?
  sub isWithOrderByRank  { 1 }  # When there is the rank adverb: order by rank ?
  sub isWithAmbiguous    { 0 }  # Allow ambiguous parse ?
  sub isWithNull         { 0 }  # Allow null parse ?
  sub maxParses          { 0 }  # Maximum number of parse tree values
  #
  # ... result getter and setter
  #
  sub getResult          { my ($self) = @_; $self->{result} }
  sub setResult          { my ($self, $result) = @_; $self->{result} = $result }

=back

So far, so good. The default actions for symbols and rules is always to concatenate any accepted token. So we expect the output of pqrsing e.g. C<(1+2)*3> to be... C<(1+2)*3>:

  package main;

  my $input = '(1+2)*3';
  my $eslifRecognizer = MyRecognizer->new($input);
  my $eslifValue = MyValue->new();

  my $result = $eslifGrammar->parse($eslifRecognizer, $eslifValue) ? $eslifValue->getResult : '??';
  printf "Default parse tree value of $input: %s\n", $result;

Usually, input is liley to have newlines, spaces, etc... we introduce as many. :discard symbols as wanted, for example to discard spaces, C-like and perl comments:

  my $grammar_v2 = $grammar_v1 . q{
  :discard ::= /[\s]+/
  :discard ::= /(?:(?:(?:\/\/)(?:[^\n]*)(?:\n|\z))|(?:(?:\/\*)(?:(?:[^\*]+|\*(?!\/))*)(?:\*\/)))/
  :discard ::= /#[^\n]*(?:\n|\z)/
  };
  $eslifGrammar = MarpaX::ESLIF::Grammar->new($eslif, $grammar_v2);

The output is the same: C<:discard> rules have skipped everything non-accepted by the graééar, but declared with C<:discard> definitions.

You will have noticed that regular expressions are allowed, and MarpaX::ESLIF arranges with the case when there is a match but the stream is not finished. For instance, reading character by character would produce the same result:

  package MyRecognizer;
  no warnings 'redefine';
  sub read                   {
                               my ($self) = @_;   # read data
                               CORE::read($self->{fh}, $self->{data}, 2) ? 1 : 0
                             }


Though please note that reading character per character, which means very few bytes per very few bytes without encoding information, can drive to a false encoding guess from MarpaX::ESLIF. Our input being for the moment pure ASCII, we could have said:

  package MyRecognizer;
  no warnings 'redefine';
  sub encoding               { 'ASCII' } # Encoding ?

=head1 NOTES

This example is adapted from L<Marpa::R2's Semantics|https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics.pod> documentation.

=head1 SEE ALSO

L<MarpaX::ESLIF>
