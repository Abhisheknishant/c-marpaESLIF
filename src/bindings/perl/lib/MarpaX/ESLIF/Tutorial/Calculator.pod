# PODNAME: MarpaX::ESLIF::Tutorial::Calculator

# ABSTRACT: MarpaX::ESLIF Calculator Tutorial

=head1 DESCRIPTION

This documentation is giving a tutorial with a calculator as example. The reader might want first to read the L<MarpaX::ESLIF::BNF> specification.

=head2 STARTUP

First we get an ESLIF instance, we use the L<Log::Any::Adapter::Stderr> implementation for logging:

  package main;
  use strict;
  use diagnostics;
  use Log::Any qw/$log/;
  use Log::Any::Adapter qw/Stderr/;
  use MarpaX::ESLIF;

  my $eslif = MarpaX::ESLIF->new($log);

=head2 Direct result with the grammar's parse() method

=head3 Grammar v1

Grammar will support parenthesis, and the C<**>, C<*>, C</>, C<+>, C<-> operators:

  my $grammar_v1 = q{
  Expression ::=
      /[\d]+/
      | '(' Expression ')'              assoc => group
     ||     Expression '**' Expression  assoc => right
     ||     Expression  '*' Expression
      |     Expression  '/' Expression
     ||     Expression  '+' Expression
      |     Expression  '-' Expression
  };

Compiling the grammar is done with:

  my $eslifGrammar = MarpaX::ESLIF::Grammar->new($eslif, $grammar_v1);

The C<::=> mean this is the top-level grammar. It could have be writen as C<:[0]:=>.

The C<||> loosen separator is a shortcut for grouping rules, Together with the associativity adverbs, the grammar listed upper is stricly equivalent to this traditional BNF form:

  Expression   ::= Expression_0
  Expression_0 ::= Expression_1
  Expression_1 ::= Expression_2
  Expression_2 ::= Expression_3
  Expression_3 ::= /[\d]+/
  Expression_3 ::= '(' Expression_0 ')'
  Expression_2 ::= Expression_3 '**' Expression_2
  Expression_1 ::= Expression_1 '*' Expression_2
  Expression_1 ::= Expression_1 '/' Expression_2
  Expression_0 ::= Expression_0 '+' Expression_1
  Expression_0 ::= Expression_0 '-' Expression_1

With I<no associativity>, this would have been equivalent to:

  Expression   ::= Expression_0
  Expression_0 ::= Expression_1
  Expression_1 ::= Expression_2
  Expression_2 ::= Expression_3
  Expression_3 ::= /[\d]+/
  Expression_3 ::= '(' Expression_3 ')'
  Expression_2 ::= Expression_2 '**' Expression_3
  Expression_1 ::= Expression_1 '*' Expression_2
  Expression_1 ::= Expression_1 '/' Expression_2
  Expression_0 ::= Expression_0 '+' Expression_1
  Expression_0 ::= Expression_0 '-' Expression_1

You can see the impact of group associativity in the C<Expression_3> rule, and the impact of right associativity in the C<Expression_2> rule.

Since internally, a pure BNF implementation is in use, the use of the C<||> loosen operator is indeed forcing the engine to act as if you would have writen in traditional BNF, this can be seen by asking for a dump of the grammar:

  #print $eslifGrammar->show;

One can already try to parse some input. Neverthless, to do so, MarpaX::ESLIF imposes to have a I<recognizer> and a I<valuator> instances:

=over

=item Recognizer interface

A recognizer must provide the following methods: C<read>, C<isEof>, C<isCharacterStream>, C<encoding>, C<data>, C<isWithDisableThreshold>, C<isWithExhaustion> and C<isWithNewline>. We will instanciate a recognizer for a string;

  package MyRecognizer;
  use strict;
  use diagnostics;
  #
  # Constructor
  #
  sub new {
    my ($pkg, $string) = @_;
    open my $fh, "<", \$string;
    bless { data => undef, fh => $fh }, $pkg
  }

C<read> returns a true value if data was read, C<isEof> returns a true value if EOF is reached, C<isCharacterStream> returns a true value if this the last data is composed of characters, C<encoding> return the encoding if known, C<data> returns the data, C<isWithDisableThreshold> switches off a hardcoded internal warning when grammar seems to have problems -; C<isWithExhaustion> enables exhaustion event and C<isWithNewline> enables newline counting for error reporting:

  #
  # Required methods
  #
  sub read                   {
                               my ($self) = @_;   # read data
                               defined($self->{data} = readline($self->{fh}))
                             }
  sub isEof                  {  eof shift->{fh} } # End of data ?
  sub isCharacterStream      {                1 } # Character stream ?
  sub encoding               {                  } # Encoding ?
  sub data                   {    shift->{data} } # data
  sub isWithDisableThreshold {                0 } # Disable threshold warning ?
  sub isWithExhaustion       {                0 } # Exhaustion event ?
  sub isWithNewline          {                1 } # Newline count ?

=item Valuator interface

A valuator must be an object that can do: C<isWithHighRankOnly>, C<isWithOrderByRank>, C<isWithAmbiguous>, C<isWithNull>, C<maxParses>, C<getResult> and C<setResult>:

  package MyValue;
  use strict;
  use diagnostics;
  #
  # Constructor
  #
  sub new { bless { result => undef}, shift }

C<isWithHighRankOnly> select only rules that have the highest eventual C<rank> adverb, C<isWithOrderByRank> orders by rank, C<isWithAmbiguous> allows ambiguous parse tree value (i.e. there is more than one value), C<isWithNull> allows a null parse, C<maxParses> gives the maximum number of wanted parse tree values (C<0> means unlimited), and for every value iteration, there are a getters and a setter on the result: C<getResult> and C<setResult>, respectively.

  #
  # Required methods
  #
  sub isWithHighRankOnly { 1 }  # When there is the rank adverb: highest ranks only ?
  sub isWithOrderByRank  { 1 }  # When there is the rank adverb: order by rank ?
  sub isWithAmbiguous    { 0 }  # Allow ambiguous parse ?
  sub isWithNull         { 0 }  # Allow null parse ?
  sub maxParses          { 0 }  # Maximum number of parse tree values
  #
  # ... result getter and setter
  #
  sub getResult          { my ($self) = @_; $self->{result} }
  sub setResult          { my ($self, $result) = @_; $self->{result} = $result }

=back

=item Immediate parsing

So far, so good. The default actions for symbols and rules is always to concatenate any accepted token. So we expect the output of parsing e.g. C<(1+2)*3> to be... C<(1+2)*3>:

  package main;

  my $input = '(1+2)*3';
  my $eslifRecognizerInterface = MyRecognizer->new($input);
  my $eslifValueInterface = MyValue->new();

  my $result = $eslifGrammar->parse($eslifRecognizerInterface, $eslifValueInterface) ? $eslifValueInterface->getResult : '??';
  printf "Default parse tree value of $input: %s\n", $result;
  # Default parse tree value of (1+2)*3: (1+2)*3

We used the C<parse()> method of the grammar, a short-hand version of parsing that I<does not allow interaction not any event>.

=head3 Grammar v2

Usually, input is likey to have newlines, spaces, etc... we introduce as many. :discard symbols as wanted, for example to discard spaces, C-like and perl comments:

  my $grammar_v2 = $grammar_v1 . q{
  :discard ::= /[\s]+/
  :discard ::= /(?:(?:(?:\/\/)(?:[^\n]*)(?:\n|\z))|(?:(?:\/\*)(?:(?:[^\*]+|\*(?!\/))*)(?:\*\/)))/
  :discard ::= /#[^\n]*(?:\n|\z)/
  };
  $eslifGrammar = MarpaX::ESLIF::Grammar->new($eslif, $grammar_v2);

We test it on an input that have things to discard, i.e.:

  $input = q{( /* C comment */1+2)
  # perl comment
  *3};
  $eslifRecognizerInterface = MyRecognizer->new($input);
  $eslifValueInterface = MyValue->new();
  $result = $eslifGrammar->parse($eslifRecognizerInterface, $eslifValueInterface) ? $eslifValueInterface->getResult : '??';
  printf "Default parse tree value of $input: %s\n", $result;
  # Default parse tree value of ( /* C comment */1+2)
  # # perl comment
  # *3: (1+2)*3

The output is the same: C<:discard> rules have skipped everything non-accepted by the grammar, but declared with C<:discard> definitions.

You will have noticed that regular expressions are allowed, and MarpaX::ESLIF arranges with the case when there is a match but the stream is not finished. For instance, reading character by character would produce the B<same> result:

  package MyRecognizer;
  no warnings 'redefine';
  sub read                   {
                               my ($self) = @_;   # read data
                               CORE::read($self->{fh}, $self->{data}, 1) ? 1 : 0
                             }


Though please note that reading character per character, which means very few bytes per very few bytes without encoding information, can drive to a false encoding guess from MarpaX::ESLIF. In such a case, you can help the engine by giving the encoding of the latest chunk of data:

  #package MyRecognizer;
  #no warnings 'redefine';
  #sub encoding               { 'ASCII' } # Encoding ?

=head3 Grammar v3

Obviously we want the calculator to be able to perform the arithmetic: taking advantage that perl will always convert when necessary depending on the context, we do not need to have an action on C</[\d]+/>, just action on the expression with the operators:

  package main;
  my $grammar_v3 = q{
  Expression ::=
      /[\d]+/
      | '(' Expression ')'              assoc => group action => ::copy[1]
     ||     Expression '**' Expression  assoc => right action => do_pow
     ||     Expression  '*' Expression                 action => do_mul
      |     Expression  '/' Expression                 action => do_div
     ||     Expression  '+' Expression                 action => do_plus
      |     Expression  '-' Expression                 action => do_minus
      :discard ::= /[\s]+/
  };
  $eslifGrammar = MarpaX::ESLIF::Grammar->new($eslif, $grammar_v3);

The actions must be implemented in the valuator interface, otherwise parsing will well with something like:

  # Can't locate object method "do_plus" via package "MyValue" at ...

=over

=item Grammar actions

The special action C<::copy[1]> is clear: take the RHS number C<1> (first is at indice C<0>) and copy its value.
The actions are trivial:

  package MyValue;
  sub do_pow   { my ($self, $left, $op, $right) = @_; $left**$right }
  sub do_mul   { my ($self, $left, $op, $right) = @_; $left*$right }
  sub do_div   { my ($self, $left, $op, $right) = @_; $left/$right }
  sub do_plus  { my ($self, $left, $op, $right) = @_; $left+$right }
  sub do_minus { my ($self, $left, $op, $right) = @_; $left-$right }

  package main;
  $input = q{(1 + 2) * 3};
  $eslifRecognizerInterface = MyRecognizer->new($input);
  $eslifValueInterface = MyValue->new();
  $result = $eslifGrammar->parse($eslifRecognizerInterface, $eslifValueInterface) ? $eslifValueInterface->getResult : '??';
  printf "Default parse tree value of $input: %s\n", $result;
  # Default parse tree value of (1 + 2) * 3: 9

What would have happened with the C<::copy[1]> action ? The default is always to concatenate I<only> what is under the engine control, i.e. C<'(' Expression ')'> would produce C<()>, because C<Expression> that is in the middle is an external object from MarpaX::ESLIF point of view.

=item Error output

Any error is automatically sent to the logger with the I<error> logging level, for example with an unparsable input:

  $input = q{(1 + 2) * 3 + ( ab};
  # Remember that we are using the 'read-one-character-per-character' implementation
  $eslifRecognizerInterface = MyRecognizer->new($input);
  $eslifValueInterface = MyValue->new();
  $eslifGrammar->parse($eslifRecognizerInterface, $eslifValueInterface);

would produce:

  --------------------------------------------
  Recognizer failure. Current state:
  [P1@9..9] Expression[0] ::= . Expression[1]
  [P2@9..9] Expression[1] ::= . Expression[2]
  [P3@9..9] Expression[2] ::= . Expression[3]
  [P4@9..9] Expression[3] ::= . /[\d]+/
  [P5@9..9] Expression[3] ::= . '('
  [P5@9..9]                   Expression[0]
  [P5@9..9]                   ')'
  [P6@9..9] Expression[2] ::= . Expression[3]
  [P6@9..9]                   '**'
  [P6@9..9]                   Expression[2]
  [P7@9..9] Expression[1] ::= . Expression[1]
  [P7@9..9]                   '*'
  [P7@9..9]                   Expression[2]
  [P8@9..9] Expression[1] ::= . Expression[1]
  [P8@9..9]                   '/'
  [P8@9..9]                   Expression[2]
  [P9@9..9] Expression[0] ::= . Expression[0]
  [P9@9..9]                   '+'
  [P9@9..9]                   Expression[1]
  [P10@9..9] Expression[0] ::= . Expression[0]
  [P10@9..9]                   '-'
  [P10@9..9]                   Expression[1]
  [R5@8..9] Expression[3] ::= '('
  [R5@8..9]                   . Expression[0]
  [R5@8..9]                   ')'
  --------------------------------------------
  Expected terminal: /[\d]+/
  Expected terminal: '('
  --------------------------------------------
  UTF-8 converted data before the failure (16 bytes)
  0x000000: 28 31 20 2b 20 32 29 20 2a 20 33 20 2b 20 28 20 (1 + 2) * 3 + ( 
  --------------------------------------------
  <<<<<< RECOGNIZER FAILURE AFTER LINE No 1 COLUMN No 16, HERE: >>>>>>
  --------------------------------------------
  UTF-8 converted data after the failure (1 bytes)
  0x000000: 61                                              a               
  --------------------------------------------

This the I<default> behaviour: parsing failure always outputs:

=over

=item the position in the grammar

=item the expected I<lexemes> (i.e. terminals)

=item an hexadecimal dump before and after the failure

=over

=item In case of a character stream, dump is the UTF-8 representation of the input

=item In case of a binary stream, dump is the exact representation of the input

=back

=back

=back

=head2 Interaction with the MarpaX::ESLIF::Recognizer's scan()/resume()/events() methods

Grammar's parse() method is great for an immediate valuation. This nevertheless imposes that no interaction is possible while parsing the input, and this include any notion of event (any eventual event in the grammar is switched off automatically - we come back later on the events).

Events are possible on both terminals (aka the lexemes) and rules.

=head3 General structure of interaction

This is always starting with an MarpaX::ESLIF::Recognizer's instance C<scan()> method, that can be called only once in a recognizer's lifetime, and only at its very beginning. It is rarelly needed to have the very early events, this is why this C<scan()> method have an optional scalar argument that, when it is a true value, enables the initial events:


  $input = q{(1 + 2) * 3};
  # Our usual ESLIF Recognizer interface
  $eslifRecognizerInterface = MyRecognizer->new($input);
  # ESLIF Recognizer engine
  my $eslifRecognizer = MarpaX::ESLIF::Recognizer->new($eslifGrammar, $eslifRecognizerInterface);
  #
  # Start scanning the input, we want initial events here
  #
  $eslifRecognizer->scan(1);

C<scan()> can stop if there is an error, or if the parsing ended, or if there are events. To check for events you use the recognizer's C<events()> method, that return a reference to an array of hashes:

  my $eventsRef = $eslifRecognizer->events();
  use Data::Dumper;
  print "Events are scan():\n" . Dumper($eventsRef);

Events remain untouched until you C<resume()> the parsing, or interact with a method that can produce new events.

There are two major event scopes: grammar events, and lexeme events.

=head4 Grammar events

These events are on symbols or parse status, and generated directly by the marpa parser engine. The syntax in MarpaX::ESLIF BNF is: C<event event_name = event_type symbol>, for example:

  my $grammar_v4 = $grammar_v3 . q{
    event ^Expression = predicted Expression
    };
  $eslifGrammar = MarpaX::ESLIF::Grammar->new($eslif, $grammar_v4);
  $eslifRecognizer = MarpaX::ESLIF::Recognizer->new($eslifGrammar, $eslifRecognizerInterface);
  $eslifRecognizer->scan(1);
  $eventsRef = $eslifRecognizer->events();
  print "Events after scan():\n" . Dumper($eventsRef);

will produce:

  Events after scan():
  $VAR1 = [
            {
              'symbol' => 'Expression',
              'event' => '^Expression',
              'type' => 4
            }
          ];

and this is because we started the recognizer with the very initial events: C<$eslifRecognizer->scan(1)>, and indeed, the grammar start with the symbol C<Expression>, we asked for the eventual prediction event and named it C<^Expression>. The C<type> is always one of the values listed in L<MarpaX::ESLIF::Event::Type>. For instance, C<4> is the value for C<MarpaX::ESLIF::Event::Type->MARPAESLIF_EVENTTYPE_PREDICTED>.

=head1 NOTES

This example is adapted from L<Marpa::R2's Semantics|https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics.pod> documentation.

=head1 SEE ALSO

L<MarpaX::ESLIF>
