name             = MarpaX-ESLIF
author           = Jean-Damien Durand <jeandamiendurand@free.fr>
license          = Perl_5
copyright_holder = Jean-Damien Durand
copyright_year   = 2017

; -- This is 95% Dagolden remarquable dist.ini

; version provider
[Git::NextVersion]  ; get version from last release tag
; Historically, tags started with a v, then I moved to a version without v
version_regexp = ^v?(\d+\.\d+\.\d+)$
 
; collect contributors list
[Git::Contributors]
 
; choose files to include
[Git::GatherDir]         ; everything from git ls-files
exclude_filename = README.pod   ; skip this generated file
exclude_filename = META.json    ; skip this generated file
exclude_filename = Changes      ; skip this generated file

[Encoding]
encoding = bytes
filename = src/3rdparty/github/tconv/3rdparty/tar/cchardet-1.0.0.tar.gz
filename = src/3rdparty/tar/pcre2-10.22.tar.gz

; Why does it copy cmake/* undef src if I say
; [GatherDir / SpecFiles]
; root   = src
; prefix = src
; !?

[GatherDir / src]
root   = src
prefix = src/.

[PruneCruft]        ; default stuff to skip
[ManifestSkip]      ; if -f MANIFEST.SKIP, skip those, too
 
; file modifications
[OurPkgVersion]     ; add $VERSION = ... to all files
[InsertCopyright]   ; add copyright at "# COPYRIGHT"
[PodnameFromClassname] ; For Moops
[PodWeaver]         ; generate Pod
config_plugin = @RJBS
[Authority]
authority = cpan:JDDPAUSE
locate_comment = 1

; generated files
[License]           ; boilerplate license
[ReadmeFromPod]     ; from Pod (runs after PodWeaver)
[ReadmeAnyFromPod]  ; create README.pod in repo directory
type = pod
filename = README.pod
location = root
[ChangelogFromGit::CPAN::Changes] ; Generated Changes from git
file_name = Changes
group_by_author = 1 ; default 0
show_author_email = 1 ; default 0
tag_regexp  = ^v?(\d+\.\d+\.\d+)$
 
; t tests
[Test::Compile]     ; make sure .pm files all compile
fake_home = 1       ; fakes $ENV{HOME} just in case
[Test::Portability] ; xt/release/portability.t (of file name)
options = test_one_dot = 0
[Test::PodSpelling] ; xt/author/pod-spell.t

[@TestingMania]
disable = Test::UnusedVars  ; Not fatal IMHO and there are cases where this cannot be avoided
disable = Test::Compile     ; Already done before
disable = Test::Portability ; Already done before
disable = Test::PodSpelling ; Already done before (not int, but just in case)

[Test::ReportPrereqs] ; show prereqs in automated test output
 
; metadata
[AutoPrereqs]       ; find prereqs from code
# skip = ^MarpaX::ESLIF::Test$
 
[Prereqs / BuildRequires]
; CMakeObjects.PL stuff
Archive::Tar = 0
Config::AutoConf::INI = 0
ExtUtils::CBuilder = 0
ExtUtils::CppGuess = 0
ExtUtils::Constant = 0
File::Basename = 0
File::chdir = 0
File::Copy = 0
File::Find = 0
File::Path = 0
IPC::Run = 0
Perl::OSType = 0
POSIX = 0
strict = 0
diagnostics = 0

[MinimumPerl]       ; determine minimum perl version
 
[MetaNoIndex]       ; sets 'no_index' in META
directory = t
directory = xt
directory = examples
directory = blog
directory = src
 
[AutoMetaResources] ; set META resources
bugtracker.rt      = 1
repository.github  = user:jddurand
homepage           = https://metacpan.org/release/%{dist}
 
[MetaProvides::Class] ; add 'provides' to META files
meta_noindex = 1        ; respect prior no_index directives
 
[MetaYAML]          ; generate META.yml (v1.4)
[MetaJSON]          ; generate META.json (v2)
 
; build system
[ExecDir]           ; include 'bin/*' as executables
[ShareDir]          ; include shared resources for File::ShareDir
; dir = share/dist/MarpaX-ESLIF
[MakeMaker::Awesome]
; But the build platforms might have different internals.
; For example the isblank stuff.
delimiter = |
header = |use IO::Handle;
header = |use IPC::Run qw/run/;
header = |use File::Spec;
header = |use File::Find;
header = |use File::Basename;
header = |use ExtUtils::CppGuess;
header = |use Config;
header = |use Config::AutoConf;
header = |use Perl::OSType qw/is_os_type/;
header = |use ExtUtils::Constant qw /WriteConstants/;
header = |
header = |autoflush STDOUT 1;
header = |
header = |print "Generating marpaESLIFEventType constants for MarpaX::ESLIF::Event::Type\n";
header = |WriteConstants(C_FILE => File::Spec->catfile('lib', 'MarpaX', 'ESLIF', 'Event', 'const-c-marpaESLIFEventType.inc'), XS_FILE => File::Spec->catfile('lib', 'MarpaX', 'ESLIF', 'Event', 'const-xs-marpaESLIFEventType.inc'), NAME => 'MarpaX::ESLIF::Event::Type', NAMES => [qw/MARPAESLIF_EVENTTYPE_NONE MARPAESLIF_EVENTTYPE_COMPLETED MARPAESLIF_EVENTTYPE_NULLED MARPAESLIF_EVENTTYPE_PREDICTED MARPAESLIF_EVENTTYPE_BEFORE MARPAESLIF_EVENTTYPE_AFTER MARPAESLIF_EVENTTYPE_EXHAUSTED MARPAESLIF_EVENTTYPE_DISCARD/]);
header = |
header = |print "Generating marpaESLIFValueType constants for MarpaX::ESLIF::Value::Type\n";
header = |WriteConstants(C_FILE => File::Spec->catfile('lib', 'MarpaX', 'ESLIF', 'Value', 'const-c-marpaESLIFValueType.inc'), XS_FILE => File::Spec->catfile('lib', 'MarpaX', 'ESLIF', 'Value', 'const-xs-marpaESLIFValueType.inc'), NAME => 'MarpaX::ESLIF::Value::Type', NAMES => [qw/MARPAESLIF_VALUE_TYPE_UNDEF MARPAESLIF_VALUE_TYPE_CHAR MARPAESLIF_VALUE_TYPE_SHORT MARPAESLIF_VALUE_TYPE_INT MARPAESLIF_VALUE_TYPE_LONG MARPAESLIF_VALUE_TYPE_FLOAT MARPAESLIF_VALUE_TYPE_DOUBLE MARPAESLIF_VALUE_TYPE_PTR MARPAESLIF_VALUE_TYPE_PTR_SHALLOW MARPAESLIF_VALUE_TYPE_ARRAY MARPAESLIF_VALUE_TYPE_ARRAY_SHALLOW/]);
header = |
header = |run([$^X, File::Spec->catfile('src', 'CMakeObjects.PL')]) or die "src/CMakeObjects.PL: $?";
header = |my @ldfrom = ();
header = |my %unique = ();
header = |
header = |find({ wanted => sub {
header = |                       if (-f $_) {
header = |                         my $cpath = File::Spec->canonpath($_);
header = |                         if (basename(dirname($cpath)) eq 'obj4perl') {
header = |                           if (! ${unique}{basename($cpath)}++) {
header = |                             push(@ldfrom, $cpath);
header = |                           }
header = |                         }
header = |                       }
header = |                     },
header = |      no_chdir => 1 }, File::Spec->curdir);
header = |
header = |#
header = |# We have a difficulty because tconv is built with C++ objects, so we need the C++ linker
header = |# We use a copy/paste of Inline-CPP-0.74/inc/ILCPPConfig/CompilerGuess.pm
header = |#
header = |sub guess_compiler {
header = |
header = |  my( $cc_guess, $libs_guess, $guesser, %configuration );
header = |
header = |  if( $Config::Config{osname} eq 'freebsd'
header = |    && $Config::Config{osvers} =~ /^(\d+)/
header = |    && $1 >= 10
header = |  ){
header = |    $cc_guess = 'clang++';
header = |    $libs_guess = '-lc++';
header = |  }
header = |  else {
header = |    $guesser = ExtUtils::CppGuess->new;
header = |    %configuration = $guesser->module_build_options;
header = |    if( $guesser->is_gcc ) {
header = |      if( $Config{cc} eq 'clang' ) {
header = |        $cc_guess = 'clang++';
header = |      } else {
header = |        $cc_guess = 'g++';
header = |      }
header = |    }
header = |    elsif ( $guesser->is_msvc ) {
header = |      $cc_guess = 'cl';
header = |    }
header = |
header = |    $cc_guess .= $configuration{extra_compiler_flags};
header = |    $libs_guess = $configuration{extra_linker_flags};
header = |
header = |    ( $cc_guess, $libs_guess )
header = |      = map { _trim_whitespace($_) } ( $cc_guess, $libs_guess );
header = |  }
header = |  return ( $cc_guess, $libs_guess );
header = |}
header = |
header = |sub _trim_whitespace {
header = |  my $string = shift;
header = |  $string =~ s/^\s+|\s+$//g;
header = |  return $string;
header = |}
header = |
header = |my ($cpp_compiler, $cpp_libs) = guess_compiler();
header = |
header = |#
header = |# Another difficulty comes from c-tconv on Windows. It is using dlfcn-win32
header = |# that will imply a dependency on psapi. We verify this library is available
header = |#
header = |if (is_os_type('Windows')) {
header = |  my $ac = Config::AutoConf->new();
header = |  $ac->push_libraries('psapi');
header = |  if ($ac->link_if_else("#include <windows.h>\n#include <psapi.h>\nint main() { EnumProcessModules(NULL, NULL, 0, NULL); }")) {
header = |    if (basename($Config{cc}) =~ /^cl/i) {
header = |      $cpp_libs .= " psapi.lib";
header = |    } else {
header = |      $cpp_libs .= " -lpsapi";
header = |    }
header = |  }
header = |}
header = |
header = |print "C++ libraries guess: $cpp_libs\n";
header = |print "Linking ESLIF\$(OBJ_EXT) using: @ldfrom\n";

WriteMakefile_arg = dynamic_lib => { OTHERLDFLAGS => $cpp_libs }
WriteMakefile_arg = INC => join(' ', map { "-I$_ " } (File::Spec->catdir('src', 'output', 'include'), File::Spec->catdir('src', 'include'), File::Spec->catdir('src', 'output', '3rdparty', 'genericLogger', 'output', 'include'), File::Spec->catdir('src', 'output', '3rdparty', 'genericLogger', 'include'), File::Spec->catdir('src', 'output', '3rdparty', 'genericStack', 'include') ) )
WriteMakefile_arg = XSMULTI => 1
WriteMakefile_arg = XSBUILD => { xs => { 'lib/MarpaX/ESLIF' => { LDFROM => join(' ', File::Spec->catfile('lib', 'MarpaX', "ESLIF\$(OBJ_EXT)"), @ldfrom) } } }

[DynamicPrereqs]
-delimiter = |
-raw = |use Config;
-raw = |if (! $Config{usethreads}) {
-raw = |  foreach (qw/PREREQ_PM BUILD_REQUIRES TEST_REQUIRES/) {
-raw = |    delete($WriteMakefileArgs{$_}{Thread}) if (exists($WriteMakefileArgs{$_}));
-raw = |    delete($FallbackPrereqs{$_}{Thread})   if (exists($FallbackPrereqs{$_}));
-raw = |  }
-raw = |}

; manifest (after all generated files)
[Manifest]          ; create MANIFEST
 
; copy META.json back to repo dis
[CopyFilesFromBuild]
copy = META.json
copy = Changes
 
; before release
[Git::Check]        ; ensure all files checked in except those generated during dzil
allow_dirty = Changes
allow_dirty = README.pod
allow_dirty = META.json
 
[CheckMetaResources]     ; ensure META has 'resources' data
[CheckPrereqsIndexed]    ; ensure prereqs are on CPAN
; [CheckChangesHasContent] ; ensure Changes has been updated
; [CheckExtraTests]   ; ensure xt/ tests pass
[TestRelease]       ; ensure t/ tests pass
[ConfirmRelease]    ; prompt before uploading
 
; releaser
; [FakeRelease]
[UploadToCPAN]      ; uploads to CPAN
 
; after release
[Git::Commit] ; commit Changes (as released)
allow_dirty = Changes
allow_dirty = README.pod
allow_dirty = META.json
commit_msg  = Release of version %v
 
[Git::Tag]          ; tag repo with custom tag
tag_format = %v
 
; NextRelease acts *during* pre-release to write $VERSION and
; timestamp to Changes and  *after* release to add a new {{$NEXT}}
; section, so to act at the right time after release, it must actually
; come after Commit_Dirty_Files but before Commit_Changes in the
; dist.ini.  It will still act during pre-release as usual
 
[NextRelease]

[Git::Commit / Commit_Changes] ; commit Changes (for new dev)
changelog = Changes
allow_dirty = README.pod
allow_dirty = META.json
 
[Git::Push]         ; push repo to remote
push_to = origin
[Clean]
