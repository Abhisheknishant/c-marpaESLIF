=for html <a href="https://travis-ci.org/jddurand/c-marpaESLIF"><img src="https://travis-ci.org/jddurand/c-marpaESLIF.svg?branch=master" alt="Travis CI build status" height="18"></a> <a href="https://badge.fury.io/gh/jddurand%2Fc-marpaESLIF"><img src="https://badge.fury.io/gh/jddurand%2Fc-marpaESLIF.svg" alt="GitHub version" height="18"></a> <a href="http://opensource.org/licenses/MIT" rel="nofollow noreferrer"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License MIT" height="18"></a>

=head1 NAME

marpaESLIF_BNF - Domain Specific Language (DSL)

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

=head2 CONVENTIONS

The marpaESLIF BNF is composed of unicode characters, in any encoding supported by the underlying convertor (L<ICU|http://site.icu-project.org/> or iconv, in order of preference). Unsignificant whitespaces, Perl-like comments and C++-like comments are discarded.

=over

=item * Symbol names consist of <bare names>, or can be enclosed in angle brackets if whitespace if desired.

They are case sensitive, and can be composed only of ASCII characters. There is no attempt to discard any leading, trailing, or repeated whitespace in angle brackets version, i.e. all the followings are different symbol names:

  this
  <this >
  < this
    >

=item there are three types of explicit terminals

=over

=item * Strings

They can be single or double-quoted, the content is any valid unicode character, and the C<\> character can be used to escape the quote or C<\> itself. The C<:i> modifier can be used to force case-insensitive match:

  'string'
  'string':i
  'string\'s'
  "string\"s\\"

=item * Character classes

They are always enclosed with left and right brackets C<[]>. Modifiers can start after a C<:> character. A character class class is nothing else but a lexically restricted regular expression.

=item * Regular expression

They are always enclosed with slashes C<//>, and the content must be valid as per the L<PCRE2 Perl Compatible Regular Expression|http://www.pcre.org/> library. Modifiers can start after the slash on the right. Regular expression patterns are by default anchored.

=back

The PCRE2 syntax is supported in its entirety, this include any PCRE2 add-on. Character classes and regular expression share the same set of modifiers, executed in order of appearance, that are:

  ----------------------------------------------------------------
  Modifiers   Explanation
  ----------------------------------------------------------------
  e           Unset back-references in the pattern will match to empty strings
  i           Case-insensitive
  j           \u, \U and \x and unset back-references will act as JavaScript standard
  m           Multi-line regex
  n           Enable Unicode properties and extend meaning of meta-characters
  s           A dot meta-character in the pattern matches all characters, including newlines
  x           Enable comments. This has some limitation due marpaESLIF semantics
  D           A dollar meta-character matches only at the end of the subject string
  J           Allow duplicate names for sub-patterns
  U           Inverts the "greediness" of the quantifiers
  a           Meta-characters will be limited to their ASCII equivalent
  u           Forces support of large codepoints
  b           Could mean "forced binary" mode
  c           Could mean "forced unicode character" mode
  A           Remove the systematic anchoring
  ----------------------------------------------------------------

Internally this correspond to this set of options in PCRE2:

  ----------------------------------------------------------------
  Modifiers         PCRE2 flag unset   PCR2 flag set
  ----------------------------------------------------------------
  e                                    PCRE2_MATCH_UNSET_BACKREF
  i                                    PCRE2_CASELESS
  j                                    PCRE2_ALT_BSUX|PCRE2_MATCH_UNSET_BACKREF
  m                                    PCRE2_MULTILINE
  n                                    PCRE2_UCP
  s                                    PCRE2_DOTALL
  x                                    PCRE2_EXTENDED
  D                                    PCRE2_DOLLAR_ENDONLY
  J                                    PCRE2_DUPNAMES
  U                                    PCRE2_UNGREEDY
  a                 PCRE2_UTF
  N                 PCRE2_UCP
  u                                    PCRE2_UTF
  b                 PCRE2_UTF          PCRE2_NEVER_UTF
  c                 PCRE2_NEVER_UTF    PCRE2_UTF
  A                 PCRE2_ANCHORED
  ----------------------------------------------------------------

=back

=head1 BNF

marpaESLIF BNF can be expressed in itself:

  /*
   * **********************
   * Meta-grammar settings:
   * **********************
   */
  :discard                       ::= whitespace
  :discard                       ::= <perl comment> 
  :discard                       ::= <cplusplus comment> 

  /*
   * ******
   * Rules:
   * ******
   */
  <statements>                   ::= statement*

  <statement>                    ::= <start rule>
                                   | <desc rule>
                                   | <empty rule>
                                   | <null statement>
                                   | <statement group>
                                   | <priority rule>
                                   | <quantified rule>
                                   | <discard rule>
                                   | <default rule>
                                   | <lexeme rule>
                                   | <completion event declaration>
                                   | <nulled event declaration>
                                   | <prediction event declaration>
                                   | <inaccessible statement>
                                   | <exception statement>
                                   | <autorank statement>

  <start rule>                   ::= ':start' <op declare> symbol
  <desc rule>                    ::= ':desc' <op declare> <quoted name>
  <empty rule>                   ::= <lhs> <op declare> <adverb list>
  <null statement>               ::= ';'
  <statement group>              ::= '{' statements '}'
  <priority rule>                ::= lhs <op declare> <priorities>
  <quantified rule>              ::= lhs <op declare> <rhs primary> <quantifier> <adverb list>
  <discard rule>                 ::= ':discard' <op declare> <rhs primary> <adverb list>
  <default rule>                 ::= ':default' <op declare> <adverb list>
  <lexeme rule>                  ::= ':lexeme' <op declare> symbol <adverb list>
  <completion event declaration> ::= 'event' <event initialization> '=' 'completed' <symbol name>
                                   | 'event' <event initialization> <op declare> 'completed' <symbol name>
  <nulled event declaration>     ::= 'event' <event initialization> '=' 'nulled' <symbol name>
                                   | 'event' <event initialization> <op declare> 'nulled' <symbol name>
  <prediction event declaration> ::= 'event' <event initialization> '=' 'predicted' <symbol name>
                                   | 'event' <event initialization> <op declare> 'predicted' <symbol name>
  <inaccessible statement>       ::= 'inaccessible' 'is' <inaccessible treatment> 'by' 'default'
  <inaccessible treatment>       ::= 'warn'
  <inaccessible treatment>       ::= 'ok'
  <inaccessible treatment>       ::= 'fatal'
  <exception statement>          ::= lhs <op declare> <rhs primary> '-' <rhs primary> <adverb list>
  <autorank statement>           ::= 'autorank' 'is' <on or off> 'by' 'default'
  <op declare>                   ::= <op declare top grammar>
                                   | <op declare lex grammar>
                                   | <op declare any grammar>
  <priorities>                   ::= <alternatives>+ separator => <op loosen> proper => 1
  <alternatives>                 ::= <alternative>+ separator => <op equal priority> proper => 1
  <alternative>                  ::= rhs <adverb list>
  <adverb list>                  ::= <adverb list items>
  <adverb list items>            ::= <adverb item>*
  <adverb item>                  ::= <action>
                                   | <left association>
                                   | <right association>
                                   | <group association>
                                   | <separator specification>
                                   | <proper specification>
                                   | <rank specification>
                                   | <null ranking specification>
                                   | <priority specification>
                                   | <pause specification>
                                   | <latm specification>
                                   | naming
                                   | <null adverb>
                                   | <symbol action>
                                   | <free action>
                                   | <event specification>
  <action>                       ::= 'action' '=>' <action name>
  <left association>             ::= 'assoc' '=>' 'left'
  <right association>            ::= 'assoc' '=>' 'right'
  <group association>            ::= 'assoc' '=>' 'group'
  <separator specification>      ::= 'separator' '=>' <single symbol>
  <proper specification>         ::= 'proper' '=>' false
                                   | 'proper' '=>' true
  <rank specification>           ::= 'rank' '=>' <signed integer>
  <null ranking specification>   ::= 'null-ranking' '=>' <null ranking constant>
                                   | 'null' 'rank' '=>' <null ranking constant>
  <null ranking constant>        ::= 'low'
                                   | 'high'
  <priority specification>       ::= 'priority' '=>' <signed integer>
  <pause specification>          ::= 'pause' '=>' 'before'
                                   | 'pause' '=>' 'after'
  <event specification>          ::= 'event' '=>' <event initialization>
  <event initialization>         ::= <event name> <event initializer>
  <event initializer>            ::= '=' <on or off>
  <event initializer>            ::=
  <on or off>                    ::= 'on'
                                   | 'off'
  <latm specification>           ::= 'latm' '=>' <false>
                                   | 'latm' '=>' <true>
  naming                         ::= 'name' '=>' <alternative name>
  <null adverb>                  ::= ','
  <symbol action>                ::= 'symbol-action' '=>' <action name>
  <free action>                  ::= 'free-action' '=>' <free name>
  <alternative name>             ::= <standard name>
  <alternative name>             ::= <quoted name>
  <event name>                   ::= <restricted ascii graph name>
                                   | ':symbol'
  lhs                            ::= <symbol name>
  rhs                            ::= <rhs primary>+
  <rhs primary>                  ::= <single symbol>
                                   | <quoted string>
                                   | <symbol name> '@' <grammar reference>
  <single symbol>                ::= symbol
                                   | <character class>
                                   | <regular expression>
  symbol                         ::= <symbol name>
  <symbol name>                  ::= <bare name>
                                   | <bracketed name>
  <action name>                  ::= <restricted ascii graph name>
                                   | '::shift'
                                   | '::undef'
                                   | '::ascii'
                                   | '::translit'
                                   | '::concat'
                                   | /::copy\[\d+\]/
  <free name>                    ::= <restricted ascii graph name>
  <quantifier>                   ::= '*'
                                   | '+'
  <signed integer>               ::= /[+-]?\d+/
  <grammar reference>            ::= <quoted string>
                                   | <signed integer>

  #
  # ---------------------------------------
  # Lexemes of the grammar given above are:
  # ---------------------------------------
  #
  # <op declare any grammar> ::= <op declare any grammar>@+1
  # <op declare top grammar> ::= <op declare top grammar>@+1
  # <op declare lex grammar> ::= <op declare lex grammar>@+1
  # <op loosen> ::= <op loosen>@+1
  # <op equal priority> ::= <op equal priority>@+1
  # <false> ::= <false>@+1
  # <true> ::= <true>@+1
  # <standard name> ::= <standard name>@+1
  # <quoted name> ::= <quoted name>@+1
  # <quoted string> ::= <quoted string>@+1
  # <character class> ::= <character class>@+1
  # <regular expression> ::= <regular expression>@+1
  # <bare name> ::= <bare name>@+1
  # <bracketed name> ::= <bracketed name>@+1
  # <restricted ascii graph name> ::= <restricted ascii graph name>@+1
  # <whitespace> ::= <whitespace>@+1
  # <perl comment> ::= <perl comment>@+1
  # <cplusplus comment> ::= <cplusplus comment>@+1
  #

  ; // This semicolon is VERY important, otherwise grammar will believe that /* ... Lexeme rules ... */ is a continuation of <grammar reference> ::= <signed integer>... Definitely NOT wanted, plus in addition /* ... Lexeme rules ... */ would trigger a PCRE2 compile exception!
  /*
   * *************
   * Lexeme rules:
   * *************
   */
  whitespace                       ~ /[\s]+/
  <perl comment>                   ~ /(?:(?:#)(?:[^\n]*)(?:\n|\z))/u
  <cplusplus comment>              ~ /(?:(?:(?:\/\/)(?:[^\n]*)(?:\n|\z))|(?:(?:\/\*)(?:(?:[^\*]+|\*(?!\/))*)(?:\*\/)))/u
  <op declare any grammar>         ~ /:\[(\d+)\]:=/
  <op declare top grammar>         ~ '::='
  <op declare lex grammar>         ~ '~'
  <op loosen>                      ~ '||'
  <op equal priority>              ~ '|'
  <true>                           ~ '1'
  <false>                          ~ '0'
  <word character>                 ~ [\w]
  <one or more word characters>    ~ <word character>+ proper => 1
  <zero or more word characters>   ~ <word character>* proper => 1
  <restricted ascii graph name>    ~ /[-!#$%&()*+.\/;<>?@\[\\\]^_`|~A-Za-z0-9][-!#$%&()*+.\/:;<>?@\[\\\]^_`|~A-Za-z0-9]*/
  <bare name>                      ~ <word character>+ proper => 1
  <standard name>                  ~ [a-zA-Z] <zero or more word characters>
  <bracketed name>                 ~ '<' <bracketed name string> '>'
  <bracketed name string>          ~ /[\s\w]+/
  <quoted string>                  ~ /(?:(?|(?:')(?:[^\\']*(?:\\.[^\\']*)*)(?:')|(?:")(?:[^\\"]*(?:\\.[^\\"]*)*)(?:")))/su
                                   | /(?:(?|(?:')(?:[^\\']*(?:\\.[^\\']*)*)(?:')|(?:")(?:[^\\"]*(?:\\.[^\\"]*)*)(?:")))/su ':' /ic?/
  <quoted name>                    ~ /(?:(?|(?:')(?:[^\\']*(?:\\.[^\\']*)*)(?:')|(?:")(?:[^\\"]*(?:\\.[^\\"]*)*)(?:")))/su
  <character class>                ~ /((?:\[(?:(?>[^\[\]]+)|(?-1))*\]))/
                                   | /((?:\[(?:(?>[^\[\]]+)|(?-1))*\]))/ ':' /[eijmnsxDJUuaNbcA]+/
  <regular expression>             ~ /(?:(?|(?:\/)(?:[^\\\/]*(?:\\.[^\\\/]*)*)(?:\/)))/su
                                   | /(?:(?|(?:\/)(?:[^\\\/]*(?:\\.[^\\\/]*)*)(?:\/)))/su /[eijmnsxDJUuaNbcA]+/

=head1 SEE ALSO

L<marpaESLIF|https://github.com/jddurand/c-marpaESLIF>, L<ICU|http://site.icu-project.org/>
