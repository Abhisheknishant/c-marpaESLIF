=encoding UTF-8

=head1 NAME

marpaESLIF_API - Extended Marpa's Scanless Interface API

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

The whole API is available with this include:

  #include <marpaESLIF.h>

There are four namespaces:

=over

=item ESLIF

The main object.

=item ESLIFGrammar

Grammar creation and inspection.

=item ESLIFRecognizer

Parsing phase.

=item ESLIFValue

Valuation phase.

=back

=head2 ESLIF

=head3 marpaESLIF_newp

  typedef struct marpaESLIFOption {
    genericLogger_t *genericLoggerp;  /* Logger. Default: NULL */
  } marpaESLIFOption_t;

  marpaESLIF_t           *marpaESLIF_newp(marpaESLIFOption_t *marpaESLIFOptionp);

Any application must start by instanciating a main ESLIF. This method is returning such a main C<marpaESLIF> object, or C<NULL> is failure, using C<marpaESLIFOptionp> that is an eventual pointer to a C<marpaESLIFOption_t> structure. This structure contain:

=over

=item genericLoggerp

A pointer to a C<genericLogger_t> instance. If it is NULL, then C<marpaESLIF> instance, neither any of the other namespaces, will do logging. Otherwise, all will inherit this logger object and use it.

=back

=head3 marpaESLIF_freev

  void                    marpaESLIF_freev(marpaESLIF_t *marpaESLIFp);

The C<marpaESLIF> destructor, with parameter C<marpaESLIFp> being an instance previously created.

=head2 ESLIFGrammar

=head3 marpaESLIFGrammar_newp

  typedef struct marpaESLIFGrammarOption {
    void   *bytep;               /* Input */
    size_t  bytel;               /* Input length in byte unit */
    char   *encodings;           /* Input encoding. Default: NULL */
    size_t  encodingl;           /* Length of encoding itself. Default: 0 */
    char   *encodingOfEncodings; /* Encoding of encoding, in ASCII encoding. Default: NULL. */
  } marpaESLIFGrammarOption_t;

  marpaESLIFGrammar_t    *marpaESLIFGrammar_newp(marpaESLIF_t *marpaESLIFp,
                                                 marpaESLIFGrammarOption_t *marpaESLIFGrammarOptionp);

This is creating a grammar object instance, with parameters:

=over

=item C<marpaESLIFp>

Object instance of the main ESLIF.

=item C<marpaESLIFGrammarOptionp>

Required pointer to a C<marpaESLIFGrammarOption_t> structure, that contain:

=over

=item C<bytep>

A pointer to the start of the grammar. Must be non-NULL.

=item C<bytel>

Number of bytes. Must be > 0.

=item C<encodings>

Pointer to a buffer containing encoding information of the grammar. Can be NULL.

=item C<encodingl>

Number of bytes of the buffer containing encoding information. Can be 0.

=item C<encodingOfEncodings>

ASCII and NUL-terminated string giving the encoding of the encoding information itself. Can be NULL.

=back

In real life-programming, grammars are assumed to always fit within a single block of memory. So there is no reader of grammar definition, we assume that C<bytep> and C<bytel> are enough for this job.

Return C<NULL> if failure, a grammar object instance on success.

=item marpaESLIFGrammar_eslifp

  marpaESLIF_t           *marpaESLIFGrammar_eslifp(marpaESLIFGrammar_t *marpaESLIFGrammarp);

Return the main ESLIF object instance from a ESLIFGrammar instance, or C<NULL> is failure.

=item marpaESLIFGrammar_ngrammari

  short                   marpaESLIFGrammar_ngrammarib(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                       int *ngrammarip);

Get the number of grammars in the value pointed by C<ngrammarip> when the later is not C<NULL>. The number of grammars is the highest indice plus one in an internal sparse array of grammars.

Return a true value on failure, a false value on failure.

=back

=head1 NOTES

Any of the object of this API is thread-safe but is not I<reentrant>. That is, if user need to access the same object from different threads, he is responsible of doing sychronization.

=head1 SEE ALSO

L<genericLogger|https://github.com/jddurand/c-genericLogger>
