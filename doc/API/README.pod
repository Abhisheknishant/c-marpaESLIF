=encoding UTF-8

=head1 NAME

marpaESLIF_API - Extended Marpa's Scanless Interface API

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

The whole API is available with this include:

  #include <marpaESLIF.h>

There are four namespaces:

=over

=item ESLIF

The main object.

=item ESLIFGrammar

Grammar creation and inspection.

=item ESLIFRecognizer

Parsing phase.

=item ESLIFValue

Valuation phase.

=back

and a transversal type:

  typedef struct marpaESLIFString {
    char   *bytep;            /* pointer bytes */
    size_t  bytel;            /* number of bytes */
    char   *encodingasciis;   /* Encoding of bytes, itself in ASCII encoding, NUL byte terminated */
    char   *asciis;           /* ASCII transliteration - never NULL if bytep is not NULL */
  } marpaESLIFString_t;

which describe what is a I<string>: this is a sequence of C<bytel> bytes, starting at C<bytep> in memory, in eventual C<encodingasciis> encoding, and transliterated as much as possible into C<asciis>.

=head2 ESLIF

Any application must start by instanciating a main ESLIF. This object is thread-safe, re-entrant, and can be reused as many times as needed, in contrary to other namespaces. The recommended usage is to create an ESLIF instance once for the entire process lifetime.

=head3 C<marpaESLIF_versions>

  const char *marpaESLIF_versions();

Returns a non-C<NULL> string describing the ESLIF version, in the form "MAJOR.MINOR.PATCH".

=head3 C<marpaESLIF_newp>

  typedef struct marpaESLIFOption {
    genericLogger_t *genericLoggerp;  /* Logger. Default: NULL */
  } marpaESLIFOption_t;

  marpaESLIF_t *marpaESLIF_newp(marpaESLIFOption_t *marpaESLIFOptionp);

This method is returning a C<marpaESLIF> object, or C<NULL> in case of failure. The parameter C<marpaESLIFOptionp> is a pointer to a C<marpaESLIFOption_t> structure, or C<NULL>. The C<marpaESLIFOption_t> has, as of this version, the single following component:

=over

=item C<genericLoggerp>

A pointer to a L<genericLogger|https://github.com/jddurand/c-genericLogger> instance. If it is C<NULL>, then ESLIF will never log. Otherwise, all namespaces will inherit this logger object and use it.

=back

=head3 C<marpaESLIF_freev>

  void marpaESLIF_freev(marpaESLIF_t *marpaESLIFp);

The destructor of a marpaESLIF instance C<marpaESLIFp> instance. No-op if C<marpaESLIFp> is C<NULL>.

=head2 ESLIFGrammar

An I<ESLIFGrammar> is a sparse array of grammars, each is identified by a I<level>, that is the indice in this array, i.e. C<0>, C<1>, and so on.

Most of the APIs in this section have two forms, one for the I<current> grammar, one for a grammar at a wanted I<indice> or I<description>. A I<description> is a string identifying a grammar, set using the C<:desc> keyword, e.g.:

  :desc :[0]: 'Description of the grammar at level 0'
  :desc :[7]: 'Description of the grammar at level 7'

The default current grammar is always at level C<0>, that must exist. Level <0> is naturally considered like the I<top level> grammar. Nevertheless it is possible to instanciate a parsing at a I<different> level, in which case current grammar in derived namespaces like the recognizer or the valuation, is the level you asked for. For example:

  A :[0]:= X          # Could have been A ::= X, '::=' is an alias for ':[0]:'
  X :[1]:= Y@+2       # Could have been X ~ Y@+2, '~' is an alias for ':[1]:'
  Y :[3]:= 'Z'

declares grammars at level C<0>, C<1> and C<3>. Grammar at level C<2> is undefined.

=head3 C<marpaESLIFGrammar_newp>

  typedef struct marpaESLIFGrammarOption {
    void   *bytep;               /* Input */
    size_t  bytel;               /* Input length in byte unit */
    char   *encodings;           /* Input encoding. Default: NULL */
    size_t  encodingl;           /* Length of encoding itself. Default: 0 */
    char   *encodingOfEncodings; /* Encoding of encoding, in ASCII encoding. Default: NULL. */
  } marpaESLIFGrammarOption_t;

  marpaESLIFGrammar_t *marpaESLIFGrammar_newp(marpaESLIF_t              *marpaESLIFp,
                                              marpaESLIFGrammarOption_t *marpaESLIFGrammarOptionp);

Creates a grammar object instance, with parameters:

=over

=item C<marpaESLIFp>

An <required> ESLIF object instance.

=item C<marpaESLIFGrammarOptionp>

A I<required> pointer to a C<marpaESLIFGrammarOption_t> structure, defined as:

=over

=item C<bytep>

A pointer to the start of the grammar. Must be non-NULL.

=item C<bytel>

Number of B<bytes>. Must be > 0.

=item C<encodings>

Pointer to a buffer containing encoding information of the grammar. Can be NULL.

=item C<encodingl>

Number of bytes of the buffer containing encoding information. Can be 0.

=item C<encodingOfEncodings>

ASCII and NUL-terminated string giving the encoding of the encoding information itself. Can be, and is usually, NULL.

=back

=back

Grammars themselves are assumed to always fit within a single block of memory. So there is no I<grammar reader> here: we assume that a single buffer starting at C<bytep>, spanning over C<bytel> bytes, is always possible and enough for a grammar definition.

Returns C<NULL> if failure, a grammar object instance on success.

=head3 C<marpaESLIFGrammar_eslifp>

  marpaESLIF_t *marpaESLIFGrammar_eslifp(marpaESLIFGrammar_t *marpaESLIFGrammarp);

Returns the ESLIF parent object instance of C<marpaESLIFGrammarp>, or C<NULL> if failure. It never returns C<NULL> if C<marpaESLIFGrammarp> is not C<NULL>.

=head3 C<marpaESLIFGrammar_ngrammarib>

  short marpaESLIFGrammar_ngrammarib(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                     int                 *ngrammarip);

Puts the number of sub-grammars in the value pointed by C<ngrammarip>, which can be C<NULL>. The number of grammars is the highest level plus one, and it is B<allowed> to have undefined grammars at any indice but level 0. For example:

  A :[0]:= X          # First grammar
  X :[1]:= Y@+2       # Second grammar
                      # Third grammar (undefined)
  Y :[3]:= 'Z'        # Fourth grammar

would return C<4>: there are four grammars, the third one being undefined.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaultsb>

  typedef struct marpaESLIFGrammarDefaults {
    char *defaultRuleActions;   /* Default action for rules */
    char *defaultSymbolActions; /* Default action for symbols */
    char *defaultFreeActions;   /* Default action for free */
  } marpaESLIFGrammarDefaults_t;

  short marpaESLIFGrammar_defaultsb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                    marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp);

Puts in the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>, the current grammar defaults, all of them being ASCII NUL terminated string pointers or C<NULL> when not set.

=over

=item defaultRuleActions

Default action for symbols, and correspond to the grammar keyword C<action>.

=item defaultSymbolActions

Default action for symbols, and correspond to the grammar keyword C<symbol-action>.

=item defaultFreeActions

Default action for symbols, and correspond to the grammar keyword C<free-action>.

=back

The keywords mentionned upper are set within a I<:default> statement, e.g.:

  :default ::= action        => myRuleAction
               symbol-action => mySymbolAction
               free-action   => myFreeAction

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaults_by_levelb>

  short marpaESLIFGrammar_defaults_by_levelb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                             marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp,
                                             int                          leveli,
                                             marpaESLIFString_t          *descp);

Put in the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>, the grammar at level C<leveli> and/or description C<descp> defaults, where a C<NULL> value for a default means it is not set.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaults_setb>

  short marpaESLIFGrammar_defaults_setb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                        marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp);

Sets all grammar defaults using the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>. A C<NULL> value for a default has the same effect as if original grammar never had the associated keyword.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaults_by_level_setb>

  short marpaESLIFGrammar_defaults_by_level_setb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                                 marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp,
                                                 int                          leveli,
                                                 marpaESLIFString_t          *descp);

Puts in the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>. A C<NULL> value for a default has the same effect as if original grammar never had the associated keyword.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammar_by_levelb>

  short marpaESLIFGrammar_grammar_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                            int                  leveli,
                                            marpaESLIFString_t  *descp,
                                            int                 *levelip,
                                            marpaESLIFString_t **descpp);

Put in the values pointed by C<levelip> and C<descpp>, which can be both C<NULL>, the level and description of wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if lower than C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

When both C<leveli> and C<descp> are set, C<descp> have precedence over C<leveli>.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_rulearray_currentb>

  short marpaESLIFGrammar_rulearray_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                             int                 **ruleipp,
                                             size_t               *rulelp);

Puts in the values pointed by C<ruleipp> and C<rulelp> a pointer to an array of integer, and the number of them, respectively, of current grammar. User must B<not> try to free C<rulelp>.

Returns a true value on failure, a false value on failure. C<*ruleipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_rulearray_by_levelb>

  short marpaESLIFGrammar_rulearray_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                              int                 **ruleipp,
                                              size_t               *rulelp,
                                              int                   leveli,
                                              marpaESLIFString_t   *descp);


Put in the values pointed by C<ruleipp> and C<rulelp> a pointer to an array of integer, and the number of them, respectively, of the grammar referenced by C<leveli> or C<descp>. 

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if lower than C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

When both C<leveli> and C<descp> are set, C<descp> have precedence over C<leveli>.

Returns a true value on failure, a false value on failure. C<*ruleipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_ruledisplayform_currentb>

  short marpaESLIFGrammar_ruledisplayform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                   int                   rulei,
                                                   char                **ruledisplaysp);

Put in the value pointed by C<ruledisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of rule name at indice C<rulei> of the current grammar.

Returns a true value on failure, a false value on failure.

Example of a rule display form:

  <lstring>

=head3 C<marpaESLIFGrammar_ruledisplayform_by_levelb>

  short marpaESLIFGrammar_ruledisplayform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   rulei,
                                                    char                **ruledisplaysp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<ruledisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of rule name at indice C<rulei> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_symboldisplayform_currentb>

  short marpaESLIFGrammar_symboldisplayform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                     int                   symboli,
                                                     char                **symboldisplaysp);

Put in the value pointed by C<symboldisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of symbol name at indice C<symboli> of the current grammar from C<marpaESLIFGrammarp>. C<symboli> is an argument of symbol actions (c.f. the documentation for actions).

Return a true value on failure, a false value on failure.

Example of a symbol display form:

  <in_string>

=head3 C<marpaESLIFGrammar_symboldisplayform_by_levelb>

  short marpaESLIFGrammar_symboldisplayform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                      int                   symboli,
                                                      char                **symboldisplaysp,
                                                      int                   leveli,
                                                      marpaESLIFString_t   *descp);

Put in the value pointed by C<symboldisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of symbol name at indice C<symboli> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>. C<symboli> is an argument of symbol actions (c.f. the documentation for actions).

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_ruleshowform_currentb>

  short marpaESLIFGrammar_ruleshowform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                int                   rulei,
                                                char                **ruleshowsp);

Put in the value pointed by C<ruleshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of rule definition at indice C<rulei> of the current grammar from C<marpaESLIFGrammarp>.

Return a true value on failure, a false value on failure.

Example of a rule show form:

  <lstring> ~ <quote> <in_string> <quote>

=head3 C<marpaESLIFGrammar_ruleshowform_by_levelb>

  short marpaESLIFGrammar_ruleshowform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   rulei,
                                                    char                **ruleshowsp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<ruleshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of rule definition at indice C<rulei> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarshowform_currentb>

  short marpaESLIFGrammar_grammarshowform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                   int                   grammari,
                                                   char                **grammarshowsp);

Put in the value pointed by C<grammarshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of grammar definition at indice C<grammari> of the current grammar from C<marpaESLIFGrammarp>. This is very exhaustive, and give internal information about all symbols and rules. See the NOTES section.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarshowform_by_levelb>

  short marpaESLIFGrammar_grammarshowform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   grammari,
                                                    char                **grammarshowsp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<grammarshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of grammar definition at indice C<grammari> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

This is very exhaustive, and give internal information about all symbols and rules. See the NOTES section.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_parseb>

  short marpaESLIFGrammar_parseb(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                 marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp,
                                 marpaESLIFValueOption_t      *marpaESLIFValueOptionp,
                                 short                        *exhaustedbp,
                                 marpaESLIFValueResult_t      *marpaESLIFValueResultp);

Please refer to the documentation of:

=over

=item C<marpaESLIFGrammar_newp>

for the C<marpaESLIFRecognizerOption_t> structure documentation.

=item C<marpaESLIFValue_newp>

for the C<marpaESLIFValueOption_t> and C<marpaESLIFValueResult_t> structures documentation.

=back

A short form of parsing and valuation, in which I<no event> is possible: the entire scanning is left to the marpaESLIF engine. The grammar at level C<0> is used.

The value pointed by C<exhaustedbp>, when not C<NULL>, is filled with a true value if the parsing exhausted (exhaustion roughly mean that the parsing stopped without consuming all the data), a false value otherwise. This flag does not depend on the existence of an exhaustion event or not.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIFGrammar_parse_by_levelb>

  short marpaESLIFGrammar_parse_by_levelb(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                          marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp,
                                          marpaESLIFValueOption_t      *marpaESLIFValueOptionp,
                                          short                        *exhaustedbp,
                                          int                           leveli,
                                          marpaESLIFString_t           *descp,
                                          marpaESLIFValueResult_t      *marpaESLIFValueResultp);

Same functionnality as C<marpaESLIFGrammar_parseb> for a wanted grammar from C<marpaESLIFGrammarp>, with these additional parameters:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

=head3 C<marpaESLIFGrammar_freev>

  void marpaESLIFGrammar_freev(marpaESLIFGrammar_t *marpaESLIFGrammarp);

The destructor of a marpaESLIFGrammar instance C<marpaESLIFGrammarp> instance. No-op if C<marpaESLIFGrammarp> is C<NULL>.

=head2 ESLIFRecognizer

One of the most important thing to understand is the notion of I<lexeme>: a I<lexeme> is a I<meta symbol> referencing another I<meta symbol> in another grammar. As such, it is a I<terminal> from the grammar point of view.

Internally, marpaESLIF have two terminal implementations:

=over

=item explicit expression

These are terminals defined explicitely in the grammar as strings, character classes or regular expressions. These terminals have no name, and will be handled automatically by the recognizer during a scanning phase. It is not possible for the end user to push an alternative that would be of such type.

=item meta symbol

These are symbols that have no LHS counterpart in the current grammar, thus must be known to another grammar. We call them lexemes, and the other grammar is used as a I<lexing grammar>.

=back

This mean that if the end-user want to have control on the parsing, he <must> make sure that he will declare as a lexeme any part of the grammar on which he migh want to have some influence.

The subtility, so, is in the declaration of terminals. For instance, rules like this:

  <sequence rule> ::= <something>* separator => [\s]+
  <something>     ::= /[a-z]+/
  <something>     ::= 'X'

is declaring no lexeme: both C<[\s]+>, C</[a-z]+/> and C<'X'> are I<explicit> expressions in the same grammar level. There is no associated name, and the user will not be able to say "I want to push an alternative whose content is C<'X'> myself". On the other hand:

  <sequence rule> ::= <something>* separator => my_separator
  <something>     ::= /[a-z]+/
  <something>     ::= my_string

  my_separator      ~ [\s]+
  my_string         ~ 'X'

declares the symbols C<my_separator> and C<my_string> as lexemes: they are not in any LHS of the grammar at level 0 (the one with C<::=> declarations), they refer to a I<grammar used as lexer> that is at level 1 (the one with C<~> declarations). The user will be able to push himself alternatives using the symbol names C<my_separator> and C<my_string>. Taking the example of the C<'X'> string, the user have the freedom to push I<something else> but C<'X'>, because we took over the lexing phase. The only important thing from the top grammar point of view, is that the I<terminal> whose name is C<my_string> is an accepted alternative. Still, the end-user will not be able to push an alternative that would correspond to the expression C</[a-z]+/> at the C<something> location.

Being able to affect the parse tree is only possible anywhen the recognizer holds on, i.e. anywhen there is an I<event>.

Secondly, if, at any location in the grammar, possible alternatives are of both types: I<explicit expression>s and lexemes (i.e. a I<meta symbol> refering another grammar), and if at least one I<explicit expression> matches, then the longests I<explicit expression>s will have have absolute precedence over any lexeme.

=head3 C<marpaESLIFRecognizer_newp>

  typedef short (*marpaESLIFReader_t)(void    *userDatavp,
                                      char   **inputcpp,
                                      size_t  *inputlp,
                                      short   *eofbp,
                                      short   *characterStreambp,
                                      char   **encodingOfEncodingsp,
                                      char   **encodingsp,
                                      size_t  *encodinglp);
  typedef struct marpaESLIFRecognizerOption {
    void                *userDatavp;                  /* User specific context */
    marpaESLIFReader_t   marpaESLIFReaderCallbackp;   /* Reader callback */
    short                disableThresholdb;           /* Disable threshold warning.  Recommended: 0 */
    short                exhaustedb;                  /* Exhaustion event.           Recommended: 0 */
    short                newlineb;                    /* Count line/column numbers.  Recommended: 0 */
    size_t               bufsizl;                     /* Minimum stream buffer size. Recommended: 0 */

    /* Excess number of bytes, in % of bufsizl, where stream buffer size is reduced */
    unsigned int         buftriggerperci;             /*                             Recommended: 50 */

    /* Policy of minimum of bytes for increase, in % of current allocated size, when */
    /*  stream buffer size need to augment */
    unsigned int         bufaddperci;                 /*                             Recommended: 50 */
  } marpaESLIFRecognizerOption_t;

  marpaESLIFRecognizer_t *marpaESLIFRecognizer_newp(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                                    marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp);

Creates a recognizer out of a C<marpaESLIFGrammarp> grammar instance.

The C<marpaESLIFReader_t> defines the prototype of a reader, referenced in the required parameter C<marpaESLIFRecognizerOptionp>. Its arguments are:

=over

=item C<userDatavp>

User opaque pointer, set in C<marpaESLIFRecognizerOptionp> and propagated as-is to the reader. There is no default value.

=item C<inputcpp>

The place where the user will set the pointer of the next available buffer. Default is C<NULL>.

=item C<inputlp>

The place where the user will set the number of bytes of the next available buffer. Default is C<0>.

=item C<eofbp>

The place where the user will set a flag saying this the end of data. Default is a false value.

=item C<characterStreambp>

The place where the user will set a flag saying this buffer I<must> be a stream of characters. Default is a false value.

=item C<encodingOfEncodingsp>

The place where the user will give in which encoding is the encoding itself. Default is <NULL>.

=item C<encodingsp>

The place where the user will give a pointer to a buffer containing encoding information, encoded using C<encodingOfEncodingsp> encoding. Default is C<NULL>.

=item C<encodinglp>

The place where the user will give a size of the buffer starting at C<*encodingsp>. Default is C<0>.

=back

Mixing binary and character streams is possible but only at the chunk level, where a chunk is the data buffer returned by the reader callback. It is up the user to be able to determine the boundaries. Here is how the character stream flag and encoding information is used by marpaESLIF at the return of the reader callback:

=over

=item 1 - User say this is a character stream

=over

=item A - Previous read was also a character streams

=over

=item a - User gave encoding (C<*encodingsp> is not C<NULL>)

If previous encoding is different, it is flushed and a new one is starting. Else previous encoding continue, this more will support incomplete character from the previous chunk.

=item b - User gave no encoding (C<*encodingsp> is C<NULL>)

It is assumed that previous encoding continue

=back

=item B - Previous read was not a stream of characters (or there was no previous read)

If user gave encoding information it is used, else encoding is guessed.

=back

=item 2 - User say this is not a character stream

=over

=item A - Previous read was a character stream

It is flushed, and binary data is appended as-is.

=item B - Previous read was not a character stream (or there was no previous read)

Binary data is appended as-is.

=back

=back

I<If> the grammar requires UTF-8 understanding of the buffer (either by using characters with code points greater than C<0xFF> in terminals, or explicitely setting the C<c> modifier to regular expressions - all of that meaning that PCRE2 expressions have the PCRE2_UTF flag), and C<If> the chunk of data was not declared as a character stream: it is assumed that it is in UTF-8 encoding. PCRE2 will check that and yell if it does not contain only valid UTF-8 characters.

The parameter C<marpaESLIFRecognizerOptionp> is a pointer to a C<marpaESLIFRecognizerOption_t> structure, where:

=over

=item C<userDatavp>

User context, propagated as-is to reader callback.

=item C<marpaESLIFReaderCallbackp>

Pointer to the reader callback. Must not be C<NULL>.

=item C<disableThresholdb>

Disable treshold warning generated by L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html>. Recommended value is a false value, because when such warning arises, it usually indicate some problem with the grammar.

=item C<exhaustedb>

Support of exhaustion event. Recommended value is a false value, because the most common usage of parsing data is to parse the full buffer up to its end of data. Nevertheless is is quite easy to find applications that support the exhaustion, for example parsing of binary structures that contain sub-structures, and so on.

=item C<newlineb>

Support of newline count. This is used when the parser fails to produce ab accurate report with line and number information. Works at the granularity of data chunk, and is meaningless if data chunk is not declared as a character stream. Any Unicode line ending sequence is considered.

=item C<bufsizl>

Default number of bytes of the internal buffer in marpaESLIF, in which I<all> data is stored and appended. If C<0>, the value used when compiling marpaESLIF library is used, itself defaulting to 1Mb. Recommended value is C<0>.

=item C<buftriggerperci>

In order to prevent internal buffer to grow indefinitely, C<buftriggerperci> is the percentage of C<bufsizl> that give a trigger on the number of unused bytes at which the internal buffer is reduced to its initial size C<bufsizl>. Recommended value is C<50>.

=item C<bufaddperci>

To prevent too many memory allocations, when marpaESLIF need to increase its internal buffer, it will do so by requesting C<bufaddperci> percent of current allocated size more bytes. Recommended value: C<50>.

=back

This method returns a recognizer pointer in case of success, C<NULL> in case of failure.

=head3 C<marpaESLIFRecognizer_grammarp>

  marpaESLIFGrammar_t *marpaESLIFRecognizer_grammarp(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

Returns the ESLIFGrammar instance parent of the C<marpaESLIFRecognizerp> instance, C<NULL> in case of failure. It never returns C<NULL> if C<marpaESLIFRecognizerp> is not C<NULL>.

=head3 C<marpaESLIFRecognizer_scanb>

  short marpaESLIFRecognizer_scanb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                   short initialEventsb,
                                   short *continuebp,
                                   short *exhaustedbp);

Start a scanless parsing using the C<marpaESLIFRecognizerp> instance. Only one such call can be done in the whole lifetime of a recognizer. Parameters are:

=over

=item initialEventsb

Traditionnally initial events are not of use and are skipped. When true, this flag enable such events.

=item continuebp

The scanning will pause as soon as there is an event or an error. When not C<NULL>, the value pointed by C<continuebp> say that if scanning can continue if it is a true value.

=item exhaustedbp

If not C<NULL>, this value pointed by C<exhaustedbp> will say if the parse is exhausted, regardless if there is an exhaustion event or not.

=back

A typical usage of the C<marpaESLIFRecognizer_scanb> method is:

  short continueb;
  short exhaustedb;

  if (! marpaESLIFRecognizer_scanb(marpaESLIFRecognizerp,
                                   0 /* initialEventsb */,
                                   &continueb,
                                   &exhaustedb)) {
    goto error_processing;
  }
  while (continueb) {
    /* See below for the events, pause and resume methods */
  }

This method returns a true value on success, a false value on failure, and can generate grammar and pause events.

=head3 C<marpaESLIFRecognizer_resumeb>

  short marpaESLIFRecognizer_resumeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                     size_t deltaLengthl,
                                     short *continuebp,
                                     short *exhaustedbp);

Resume the scanning. All parameters have the same meaning as for C<marpaESLIFRecognizer_scanb>, with an additional C<deltaLengthl> that say to the recognizer to skip this given number of byte before going on. A typical usage is:

  short continueb;
  short exhaustedb;

  if (! marpaESLIFRecognizer_scanb(marpaESLIFRecognizerp,
                                   0 /* initialEventsb */,
                                   &continueb,
                                   &exhaustedb)) {
    goto error_processing;
  }
  while (continueb) {
    /* See below for the events and pause */
    /* ... */
    /* Resume */
    if (! marpaESLIFRecognizer_resumeb(marpaESLIFRecognizerp,
                                       0,
                                       &continueb,
                                       &exhaustedb)) {
      goto error_processing;
    }
  }

This method can generate grammar and pause events.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_alternativeb>

  typedef struct marpaESLIFAlternative {
    char                   *lexemes;        /* Lexeme name */
    marpaESLIFValueResult_t value;          /* Value */
    size_t                  grammarLengthl; /* Length in the grammar (1 == token-stream model) */
  } marpaESLIFAlternative_t;

  short marpaESLIFRecognizer_lexeme_alternativeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                 marpaESLIFAlternative_t *marpaESLIFAlternativep);

It is possible to inject arbitrarty lexemes outside of the internal scanner. Such external lexemes are described using a C<marpaESLIFAlternative_t> structure, containing:

=over

=item lexemes

The lexeme name as per the grammar. Must be different than C<NULL>.

=item value

A structure describing the value. Please refer to the "value" namespace below for explanation. Please note that, in contrary to the "value" namespace, where a context for a value must be different than zero, eveyrthing is permitted in case of an alternative.

=item grammarLengthl

The number of grammar tokens taken by this alternative. A highly recommended value is C<1>, which correspond to the tradional "token-stream" model. This number must be greater than zero, and putting a value greater than C<1>, will make the parser believe that your alternative has consumed as many terminals.

=back

In any case, if this external value contains a pointer to something that should be freed, it is the user's responsibility to keep track of that.

Because this is representing a lexeme, which is always of type ARRAY in the value stack (i.e. a pointer to bytes together with an associated length), here is how the rule and symbol callbacks can distinguish from user-defined alternatives from the alternatives coming from the internal recognition: the pointer is non-C<NULL>, but the length is C<0>, and the context is C<0> in a rule callback, i.e

=over

=item Rule callbacks

The stack type of the item at an indice C<indicei> is ARRAY, the context is C<0> (i.e. a reserved value), and the array is dereferenced to a non-C<NULL> pointer with a zero length:

  short myRuleCallback(void              *userDatavp,
                       marpaESLIFValue_t *marpaESLIFValuep,
                       int                arg0i,
                       int                argni,
                       int                resulti,
                       short              nullableb) {

    short              arrayb;
    void              *bytep;
    size_t             bytel;
    int                contexti;
    marpaESLIFValue_t *marpaESLIFValuep;

    if (! nullableb) {
      /* There is something in the stack - let's try arg0i */

      if (! marpaESLIFValue_stack_is_arrayb(marpaESLIFValuep,
                                            arg0i,
                                            &arrayb)) {
        goto err;
      }
      if (arrayb) {
        if (! marpaESLIFValue_stack_get_arrayb(marpaESLIFValuep,
                                               arg0i
                                               &contexti,
                                               &bytep,
                                               &bytel,
                                               NULL /* shallowbp */)) {
          goto err;
        }
        if ((! contexti) && (bytep != NULL) && (bytel <= 0)) {
          /* This is a user-defined lexeme */
          marpaESLIFValuep = (marpaESLIFValue_t *) bytep;
          /* Here, only the user knows what it is about */
        }
      }
    }
    /* ... */
    return 1;

  err:
    return 0;
  }

=item Symbol callbacks

Same logic, except that you receive directly the "array" description on the stack:

  short mySymbolCallback(void              *userDatavp,
                         marpaESLIFValue_t *marpaESLIFValuep,
                         char              *bytep,
                         size_t             bytel,
                         int                resulti) {

    marpaESLIFValue_t *marpaESLIFValuep;

    if ((bytep != NULL) && (bytel <= 0)) {
      /* This is a user-defined lexeme */
      marpaESLIFValuep = (marpaESLIFValue_t *) bytep;
      /* Here, only the user knows what it is about */
    }
  }

=back

Please note that user-defined lexemes can trigger a I<lexeme after> event, though the information retreived with C<marpaESLIFRecognizer_lexeme_last_pauseb> will never show anything else than what correspond to real input stream, c.f. the C<lengthl> parameter of the method C<marpaESLIFRecognizer_lexeme_completeb> described just after.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_completeb>

  short marpaESLIFRecognizer_lexeme_completeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                              size_t lengthl);

Say to the recognizer pointed C<marpaESLIFRecognizerp> by that the current set of lexeme alternatives is complete, and that the stream should advance by C<length> bytes, where bytes is really the number of bytes in the internal recognizer buffer, i.e. an UTF-8 sequence of code points in case of a character-oriented stream. The reader callback may be called if necessary, in case the caller say to advance by more bytes than what is currently available. It is an error to specify more bytes than the recognizer can get (and eventually transform, in case of character-stream oriented buffer) from the reader. A a value of C<0> for the length is legal.

If a I<lexeme after> event is triggered, C<marpaESLIFRecognizer_lexeme_last_pauseb> will show as many bytes as C<lengthl>. And because it is guaranteed that C<marpaESLIFRecognizer_lexeme_last_pauseb> returns a pointer to NUL-terminated buffer, the extreme case is that last pause can be an empty string "" when the alternative has been pushed using a user-defined value.

This method can generate grammar and pause events.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_readb>

  short marpaESLIFRecognizer_lexeme_readb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          marpaESLIFAlternative_t *marpaESLIFAlternativep);
                                          size_t lengthl);

A short-hand version of lexeme management that is pushing an alternative and do completion in one call.

This method can generate grammar and pause events.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_tryb>

  short marpaESLIFRecognizer_lexeme_tryb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                         char *lexemes,
                                         short *matchbp);

Try to match the lexeme with name C<lexemes> that must be non-C<NULL> against the input seen by the recognizer. Returns in C<matchbp>, when not C<NULL>, a true value if there is a match, a false value otherwise. This method generates no event.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_discard_tryb>

  short marpaESLIFRecognizer_discard_tryb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          short *matchbp);

Try to match the :discard rule against the input seen by the recognizer. Returns in C<matchbp>, when not C<NULL>, a true value if there is a match, a false value otherwise. This method generates no event.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_lexeme_expectedb>

  short marpaESLIFRecognizer_lexeme_expectedb(marpaESLIFRecognizer_t   *marpaESLIFRecognizerp,
                                              size_t                   *nLexemelp,
                                              char                   ***lexemesArraypp);

For the current recognizer C<marpaESLIFRecognizerp>, get the list of I<lexemes> expected. C<*nLexemelp>, if not C<NULL>, is filled with the number of expected lexemes, and C<*lexemesArraypp>, if not C<NULL>, will contain the array of NUL-terminated ASCII symbol names.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_isEofb>

  short marpaESLIFRecognizer_eofb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp, short *eofbp);

Returns in the value pointed by C<eofbp> the current EOF state, when it is not C<NULL>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_event_onoffb>

  typedef enum marpaESLIFEventType {
    MARPAESLIF_EVENTTYPE_NONE       = 0x00,
    MARPAESLIF_EVENTTYPE_COMPLETED  = 0x01, /* Grammar event */
    MARPAESLIF_EVENTTYPE_NULLED     = 0x02, /* Grammar event */
    MARPAESLIF_EVENTTYPE_PREDICTED  = 0x04, /* Grammar event */
    MARPAESLIF_EVENTTYPE_BEFORE     = 0x08, /* Just before lexeme is commited */
    MARPAESLIF_EVENTTYPE_AFTER      = 0x10, /* Just after lexeme is commited */
    MARPAESLIF_EVENTTYPE_EXHAUSTED  = 0x20, /* Exhaustion */
    MARPAESLIF_EVENTTYPE_DISCARD    = 0x40  /* Discard */
  } marpaESLIFEventType_t;

  short marpaESLIFRecognizer_event_onoffb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          char                   *symbols,
                                          marpaESLIFEventType_t   eventSeti,
                                          short                   onoffb);

For the recognizer pointed by C<marpaESLIFRecognizerp>, switches on or off the event types C<eventSeti> (which is a bit mask of event type), depending of C<onoffb> value, at symbol with name C<symbols> (a NUL terminated ASCII string) of current grammar. Setting on or off a non-existing event is a no-op. There are eight type of events, described with the enum C<marpaESLIFEventType_t>:

=over

=item C<MARPAESLIF_EVENTTYPE_NONE>

No event -;

=item MARPAESLIF_EVENTTYPE_COMPLETED

Completion event. This can happen only for meta symbol names. In the grammar this is declared with:

  event start$ = completed symbolname

=item MARPAESLIF_EVENTTYPE_NULLED

Nulled event. This can happen only for meta symbol names. In the grammar this is declared with:

  event start$ = nulled symbolname

=item MARPAESLIF_EVENTTYPE_PREDICTED

Prediction event. This can happen only for meta symbol names. In the grammar this is declared with:

  event start$ = predicted symbolname

=item MARPAESLIF_EVENTTYPE_BEFORE

I<Lexeme before> event. This can happen only for lexemes that are predicted by the scanning. In the grammar this is declared with:

  :lexeme ::= lexemename pause => before event => eventname

=item MARPAESLIF_EVENTTYPE_AFTER

I<Lexeme before> event. This can happen only for lexemes after they are pushed as alternatives by the scanning. In the grammar this is declared with:

  :lexeme ::= lexemename pause => after event => eventname

=item MARPAESLIF_EVENTTYPE_EXHAUSTED

Exhaustion event. It has no name, and is possible only if the recognizer is instanciated with the C<exhaustedb> flag being a true value in the C<marpaESLIFRecognizerOption_t> structure.

=item MARPAESLIF_EVENTTYPE_DISCARD

Discard event. This can happen only for C<:discard> rules, and happen everytime a C<:discard> rule is completed at the top-level grammar. In the grammar this is declared with:

  :discard ::= whitespace event => discard_whitespace

=back

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_eventb>

  typedef struct marpaESLIFEvent {
    marpaESLIFEventType_t type;
    char                 *symbols; /* Symbol name, NULL if exhausted event, ':discard' if discard event */
    char                 *events;  /* Event name, always NULL if exhaustion eent */
  } marpaESLIFEvent_t;

  short marpaESLIFRecognizer_eventb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                    size_t                  *eventArraylp,
                                    marpaESLIFEvent_t      **eventArraypp);

Retreive the current list of events within the recognizer pointed by C<marpaESLIFRecognizerp>, putting in the value pointed by C<eventArraylp>, if it is not NULL, the number of event, and in the value pointed by C<eventArraypp>, if it not NULL, the list of these events. An event is always a structure of type C<marpaESLIFEvent_t> containing:

=over

=item type

The type of event. C.f. upper section for a description of C<marpaESLIFRecognizer_t> type.

=item symbols

The name of the symbol that triggered the event. Always a NUL-terminated ASCII string, except for exhaustion where it is C<NULL>.

=item events

The name of the event. Always a NUL-terminated ASCII string, except for exhaustion where it is C<NULL>.

=back

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_progressLogb>

  short marpaESLIFRecognizer_progressLogb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          int                     starti,
                                          int                     endi,
                                          genericLoggerLevel_t    logleveli);

Send to the logger configured at the marpaESLIF instanciation step, the current progress of parsing of the C<marpaESLIFRecognizerp> recognizer instance. Logging is do at level C<logleveli> (c.f. L<genericLogger|https://github.com/jddurand/c-genericLogger> documentation), and from C<starti> to C<endi> indices. The C<starti> and C<endi> indices are Earleme Set Ids, and obey the Perl language convention, i.e. a negative indice means it far back from the end. The format of the strings generated is totally under the L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper> library. This method should be used when the end user want to have a progress report during valuation, c.f. the C<marpaESLIFValue_value_startb> and C<marpaESLIFValue_value_lengthb> methods.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_inputb>

  short marpaESLIFRecognizer_inputb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                    char                   **inputsp,
                                    size_t                  *inputlp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns the current internal buffer state, i.e.:

=over

=item inputsp

If not C<NULL>, will contain the current input internal buffer pointer.

=item inputlp

If not C<NULL>, will contain the current input internal buffer length.

=back

These pointers are intentionnaly not having a I<const> keyword, though it is obvious that any attempt to modify C<*inputsp> or C<*inputlp> is likely to make the process crash. The internal buffer may I<not> correspond to what the callback returned in case there is character conversion: in this case the internal buffer contains UTF-8 character sequences.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_inputb>

  short marpaESLIFRecognizer_locationb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                       size_t *linelp,
                                       size_t *columnlp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns the current absolute location in terms of line and column numbers:

=over

=item linelp

If not C<NULL>, will contain the line number.

=item columnlp

If not C<NULL>, will contain the column number.

=back

These values are meaningful only if the recognizer option setted C<newlineb> to a true value, otherwise line number is fixed to C<1>, and column number if fixed to C<0>.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_last_pauseb>

  short marpaESLIFRecognizer_lexeme_last_pauseb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                                char                    *lexemes,
                                                char                   **pausesp,
                                                size_t                  *pauselp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream that generated a I<lexeme pause> event for lexeme C<lexemes> in the value pointed by C<pausesp> if it is not NULL, and the length in the value pointed by C<pauselp> if it is not NULL. For convenience if the last pause is not NULL, the buffer holding the pause information is always NUL-terminated, even if the C<\0> NUL character is I<not> in the returned length. In case of user-defined alternatives, the empty string "" is returned in C<pausesp>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_lexeme_last_tryb>

  short marpaESLIFRecognizer_lexeme_last_tryb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                              char                    *lexemes,
                                              char                   **trysp,
                                              size_t                  *trylp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream into the value pointed by C<trysp>, when it is non-C<NULL>, and corresponding length in the value pointed by C<trylp> when it is is non-C<NULL>, of the last successful try for lexeme C<lexemes>, via a call to C<marpaESLIFRecognizer_lexeme_tryb>. If C<*trysp> is non-NULL, it is guaranteed that C<*trylp> is greater than zero, and the block of memory is NUL-terminated, even if the additional NUL byte will not be included into C<trylp>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_discard_last_tryb>

  short marpaESLIFRecognizer_discard_last_tryb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                               char                   **trysp,
                                               size_t                  *trylp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream into the value pointed by C<trysp>, when it is non-C<NULL>, and corresponding length in the value pointed by C<trylp> when it is is non-C<NULL>, of the last successful discard try, via a call to C<marpaESLIFRecognizer_discard_tryb>. If C<*trysp> is non-NULL, it is guaranteed that C<*trylp> is greater than zero, and the block of memory is NUL-terminated, even if the additional NUL byte will not be included into C<trylp>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_readb>

  short marpaESLIFRecognizer_readb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                   char                   **inputsp,
                                   size_t                  *inputlp);

Forces a call to the reader callback. All parameters have the semantic as in the method C<marpaESLIFRecognizer_inputb>.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_last_completedb>

  short marpaESLIFRecognizer_last_completedb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                             char                    *names,
                                             char                   **offsetpp,
                                             size_t                  *lengthlp);

Convenience method that, for the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns the I<absolute offset> since the beginning of the scanning in the value pointed by C<offsetpp> if it not C<NULL>, and the length in the value pointed by C<lengthlp> if it is not C<NULL>, of the last completion for symbol C<names>, that must not be C<NULL>. This I<absolute offset> is computed without consideration of any turnaround, thus if the amount of data that has been scanned is larger what a C<char *> can adress, the offset value will not be reliable. Same remark for the length.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_freev>

  void marpaESLIFRecognizer_freev(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

The destructor of a marpaESLIFRecognizer instance C<marpaESLIFRecognizerp> instance. No-op if C<marpaESLIFRecognizerp> is C<NULL>.

=head2 ESLIFValue

At any point in the parsing lifetime it is possible to call for parse tree values. Traditionnaly this is happening when all data has been scanned, or when the parsing has exhausted.

=head3 C<marpaESLIFValue_newp>

  typedef short (*marpaESLIFValueRuleCallback_t)  (void              *userDatavp,
                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                   int                arg0i,
                                                   int                argni,
                                                   int                resulti,
                                                   short              nullableb);

  typedef short (*marpaESLIFValueSymbolCallback_t)(void              *userDatavp,
                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                   char              *bytep,
                                                   size_t             bytel,
                                                   int                resulti);

  typedef void  (*marpaESLIFValueFreeCallback_t)  (void              *userDatavp,
                                                   int                contexti,
                                                   void              *p,
                                                   size_t             sizel);

  typedef marpaESLIFValueRuleCallback_t   (*marpaESLIFValueRuleActionResolver_t)  (void              *userDatavp,
                                                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                                                   char              *actions);

  typedef marpaESLIFValueSymbolCallback_t (*marpaESLIFValueSymbolActionResolver_t)(void              *userDatavp,
                                                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                                                   char              *actions);

  typedef marpaESLIFValueFreeCallback_t   (*marpaESLIFValueFreeActionResolver_t)  (void              *userDatavp,
                                                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                                                   char              *actions);

  typedef struct marpaESLIFValueOption {
    void                                 *userDatavp;            /* User specific context */
    marpaESLIFValueRuleActionResolver_t   ruleActionResolverp;
    marpaESLIFValueSymbolActionResolver_t symbolActionResolverp;
    marpaESLIFValueFreeActionResolver_t   freeActionResolverp;
    short                                 highRankOnlyb;         /* Recommended: 1 */
    short                                 orderByRankb;          /* Recommended: 1 */
    short                                 ambiguousb;            /* Recommended: 0 */
    short                                 nullb;                 /* Recommended: 0 */
    int                                   maxParsesi;            /* Recommended: 0 */
  } marpaESLIFValueOption_t;

  marpaESLIFValue_t *marpaESLIFValue_newp(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                          marpaESLIFValueOption_t *marpaESLIFValueOptionp);

where C<userDatavp> is a user opaque value, holding user specific context. Action resolvers are looked up later in this section. The other parameters are:

=over

=item highRankOnlyb

Actions can have a I<rank>, e.g.:

  my_rule ::= I J 'string terminal' rank => 2
  my_rule ::= K L 'string terminal' rank => 1

say that C<my_rule> have two alternatives, with different ranks.

I<If> the next parameter C<orderByRankb> is a true value, then only rule with highest rank will be taken into account. This is a nice nice way to have a grammar ambiguous by nature, though having a non-ambiguous parse tree value from it.

=item orderByRankb

Specify if the rank is to be used.

=item ambiguousb

Specify if parse tree valuation can be ambiguous. Application's choice -;

=item nullb

Allow a parse tree valuation to produce nothing. It is recommended to set this to a false value.

=item maxParsesi

In case of ambiguity, there can be a lot of parse tree valuation results. If greater than zero, C<maxParsesi> is a higher limit on such number.

=back

Valuation lifetime is on the top-level grammar and has two main entry points:

=over

=item Valuation of terminals

Terminals are what comes directly from the input stream. From grammar point of view, this correspond to string, character class, regular expressions, or lexemes.

=item Valuation of rules

Indeed, the valuation lifetime of something like e.g.:

  this_rule ::= 'string terminal'

is:

=over

=item 1 - Evaluate C<'string terminal'>

=item 2 - Evaluate C<this_rule>

=back

and nothing impose that the valuation result of C<my_rule> would be same as C<'string terminal'> valuation result.

=back

The functions holding valuation results are totally unknown from marpaESLIF, which is always asking to user-space for a function pointer of the correct type, whenever needed. For that it is using I<action resolvers>. An action resolver is always called for a given I<action name> C<actions>, guaranteed to a NUL-terminated ASCII string. In other terms marpaESLIF will always call the actions resolver like this:

=over

=item For rules

  ruleActionp = ruleActionResolverp(userDatavp, marpaESLIFValuep, actions)

=item For symbols

  symbolActionp = symbolActionResolverp(userDatavp, marpaESLIFValuep, actions)

=item For free

  freeActionp = freeActionResolverp(userDatavp, marpaESLIFValuep, actions)

=back

and nothing impose the action resolvers to always return the same function pointer for a given C<action> NUL-terminated ASCII string.

The value result itself is also not under marpaESLIF control, though the later requires the user to manipulate a I<stack>, and to assign to every entry in the stack a I<value type>, and a I<value context>. So there is a notion of I<user stack>, which start at indice number C<0>, and whose length is determined by the parse tree value location. The context of every I<value> in the stack is nothing else but a free number different than zero that should describe what it is, and has a meaning only for the end-user. It is important to set a correct context when assigning values to the stack, because this is how the I<memory free> function pointer, another function leaving in user space, will know how to react. For example a rule like this:

  my_rule ::= I J 'string terminal' action => my_action

could be called with output stack indice C<0> and input stack indices C<0> for C<I>, C<1> for C<J>, and C<2> for C<K>. It is the end user that knows what it is all about, through the famous I<context>. Suppose that types of data would be a pointer (C<PTR> below) with context value C<17>, an integer (C<INT> below) with context value C<216>, and a short (C<SHORT> below) with context value C<43>, and that the end user decided that the result is a long with context C<20>, then a representation of the stack is:

          Rule:    my_rule     =    I      J   'string terminal'
  --------------------------------------------------------------
  Stack indice:          0     =    0      1                   2
          Type:       LONG        PTR    INT               SHORT
       Context:         20         17    216                  43

You will note that:

=over

=item The context of the terminal is a short !?

The <'string terminal'> terminal is coming from input stream. There is I<no> associated symbol, and the function that manage symbols is covered by this grammar statement:

  :default ::= symbol-action => my_symbol_action

marpaESLIF called the symbol action resolver C<symbolActionResolverp> for action C<"my_symbol_action">, the later returning function pointer C<my_symbol_actionp>, and marpaESLIF called this function pointer like this:

  my_symbol_actionp(userDatavp, marpaESLIFValuep, p, l, 2)

where C<p> is a pointer to a copy of input stream C<'string terminal'>, of size C<l>, asking for the result to be pushed at stack indice number C<2>. It is the user that decided that it will put a short value at indice 2, with context C<43>.

=item You talk about value types and context in the stack, but B<how> can this be set?

marpaESLIF provide stack manipulation functions, and it is simply impossible for the end-user to manipulate the stack without using these functions. Stack itself is maintained inside marpaESLIF. Please see all C<marpaESLIFValue_stack_xxx> stack functions documented later.

=item Stack number indice C<0> is in I<both input and output> indices

This mean that, at any time, a stack indice can be replaced by another. This is a decision of the parse tree engine, based on rule definitions.

Suppose that valuation of rule C<my_rule>, there is already something at indice C<0> in the stack and it is a pointer!? marpaESLIF will I<automatically> call for I<memory free> action on this indice, before replacing it by the C<my_rule> result. The I<free action> is set at the grammar level:

  :default ::= free-action => my_free_action

=back

Full history of our example rule C<my_rule> action is then:

=over

=item 1 - Call the action resolver for C<"my_action">

The function call is equivalent to

  ruleActionResolverp(userDatavp, marpaESLIFValuep, "my_action")

We suppose that it returned a function pointer to C<my_actionp>, a function that exist in user-space.

=item 2 - Call C<my_actionp>

The function call is

  my_actionp(userDatavp, marpaESLIFValuep, 0/* arg0i */, 2/* argni */, 0/* resulti */, 0/* nullableb */)

What is this C<nullableb> flag!? Well, it means what it means: sometimes a rule is nullable, for example the empty rule:

  nullableRule ::= action => my_action2;

or a sequence rule:

  nullableRule ::= item* action => my_action2

Then, and only in these cases, the C<nullableb> flag is a true value, C<arg0i> and C<argni> will be both C<-1>, e.g. (with C<my_action2p> being the rule resolver result for action C<"my_action2">):

  my_action2p(userDatavp, marpaESLIFValuep, -1/* arg0i */, -1/* argni */, 0/* resulti */, 1/* nullableb */)

Ok, so finally C<my_actionp> is called, and it decided to return a value of type I<long> and context C<20>.

=item 3 - Call the free resolver for C<"my_free_action">

The function call is equivalent to

  freeActionResolverp(userDatavp, marpaESLIFValuep, "my_free_action")

Suppose that it returned a function pointer to C<my_free_actionp>, a function that exist in user-space.

=item 4 - Call C<my_free_actionp>

  my_free_actionp(userDatavp, 17, p, l)

where C<p> is a pointer to the memory holding previous value at stack indice C<0>. C<l> is zero in this case, we explain later when it can be different than zero. C<17> is the context, so that the function pointer C<my_free_actionp> knows what we are talking about.

=item 5 - Put user data at stack indice C<0> and context C<20>

=back

Nothing differentiate symbol actions v.s. rule action except that there is no range of indices in input, only a single indice.

Returns C<NULL> is no valuation is possible at this stage, else return a non-C<NULL> value.

=head3 C<marpaESLIFValue_recognizerp>

  marpaESLIFRecognizer_t *marpaESLIFValue_recognizerp(marpaESLIFValue_t *marpaESLIFValuep);

Returns the marpaESLIF's recognizer instance used to create the C<marpaESLIFValuep> instance.

=head3 C<marpaESLIFValue_valueb>

  typedef enum marpaESLIFValueType {
    MARPAESLIF_VALUE_TYPE_UNDEF = 0,
    MARPAESLIF_VALUE_TYPE_CHAR,
    MARPAESLIF_VALUE_TYPE_SHORT,
    MARPAESLIF_VALUE_TYPE_INT,
    MARPAESLIF_VALUE_TYPE_LONG,
    MARPAESLIF_VALUE_TYPE_FLOAT,
    MARPAESLIF_VALUE_TYPE_DOUBLE,
    MARPAESLIF_VALUE_TYPE_PTR,
    MARPAESLIF_VALUE_TYPE_PTR_SHALLOW,
    MARPAESLIF_VALUE_TYPE_ARRAY,
    MARPAESLIF_VALUE_TYPE_ARRAY_SHALLOW
  } marpaESLIFValueType_t;

  typedef struct marpaESLIFValueResult {
    marpaESLIFValueType_t type;
    union {
      char c;          /* Value is a char */
      short b;         /* Value is a short */
      int i;           /* Value is an int */
      long l;          /* Value is a long */
      float f;         /* Value is a float */
      double d;        /* Value is a double */
      void *p;         /* Value is a pointer */
    } u;
    int contexti;      /* Free value meaninful to the user */
    size_t sizel;      /* Length of data in case value is an ARRAY - always 0 otherwise */
  } marpaESLIFValueResult_t;

  short marpaESLIFValue_valueb(marpaESLIFValue_t       *marpaESLIFValuep,
                               marpaESLIFValueResult_t *marpaESLIFValueResultp);

Calls for parse tree valuation. Parameter C<marpaESLIFValueResultp> can be C<NULL>, meaning that the end-user is not interested by the value. Otherwise, this a pointer to a structure of type C<marpaESLIFValueResult_t> hosting rhe result, that is <always> at stack indice number C<0>, where:

=over

=item type

The type of the value. This is the enum C<marpaESLIFValueType_t> that can have these values:

=over

=item MARPAESLIF_VALUE_TYPE_UNDEF

Value is undefined. This is a valid type by itself and user is allowed to push an undefined value in the stack.

=item MARPAESLIF_VALUE_TYPE_CHAR

Value is a C<C>'s C<char>.

=item MARPAESLIF_VALUE_TYPE_SHORT

Value is a C<C>'s C<short>.

=item MARPAESLIF_VALUE_TYPE_INT

Value is a C<C>'s C<int>.

=item MARPAESLIF_VALUE_TYPE_LONG

Value is a C<C>'s C<long>.

=item MARPAESLIF_VALUE_TYPE_FLOAT

Value is a C<C>'s C<float>.

=item MARPAESLIF_VALUE_TYPE_DOUBLE

Value is a C<C>'s C<double>.

=item MARPAESLIF_VALUE_TYPE_PTR

Value is a C<C>'s C<void *> pointer.

=item MARPAESLIF_VALUE_TYPE_PTR_SHALLOW

Value is a C<C>'s C<void *> shallow pointer.

=item MARPAESLIF_VALUE_TYPE_ARRAY

Value is a tuple of C<C>'s C<void *> and C<C>'s C<size_t> size.

=item MARPAESLIF_VALUE_TYPE_ARRAY_SHALLOW

Value is a tuple of a shallow C<C>'s C<void *> and C<C>'s C<size_t> size.

=back

=item u

This is an union whose member to take depend on C<type>:

=over

=item u.c

Contains the C<C>'s C<char> value when type is C<MARPAESLIF_VALUE_TYPE_CHAR>.

=item u.b

Contains the C<C>'s C<short> value when type is C<MARPAESLIF_VALUE_TYPE_SHORT>.

=item u.i

Contains the C<C>'s C<int> value when type is C<MARPAESLIF_VALUE_TYPE_INT>.

=item u.l

Contains the C<C>'s C<long> value when type is C<MARPAESLIF_VALUE_TYPE_LONG>.

=item u.f

Contains the C<C>'s C<float> value when type is C<MARPAESLIF_VALUE_TYPE_FLOAT>.

=item u.d

Contains the C<C>'s C<double> value when type is C<MARPAESLIF_VALUE_TYPE_DOUBLE>.

=item u.p

Contains the C<C>'s C<void *> value when type is C<MARPAESLIF_VALUE_TYPE_PTR>, C<MARPAESLIF_VALUE_TYPE_PTR_SHALLOW>, C<MARPAESLIF_VALUE_TYPE_ARRAY> or C<MARPAESLIF_VALUE_TYPE_ARRAY_SHALLOW>.

=back

=item contexti

Contains the user's context, or C<0> if this was not instanciated by the end-user.

=item sizel

Contains the size of the memory pointed by C<u.p> when type is C<MARPAESLIF_VALUE_TYPE_PTR>, C<MARPAESLIF_VALUE_TYPE_PTR_SHALLOW>, C<MARPAESLIF_VALUE_TYPE_ARRAY> or C<MARPAESLIF_VALUE_TYPE_ARRAY_SHALLOW>.

=back

The return value of C<marpaESLIFValue_valueb> is always:

=over

=item 1 on success

=item 0 on end

=item -1 on failure

=back

I.e. a typical usage is:

  while (1) {
    short rcValueb = marpaESLIFValue_valueb(marpaESLIFValuep, NULL);
    if (rcValueb < 0) {
      goto err;
    } else if (rcValueb == 0) {
      break;
    }
  }

=head3 C<marpaESLIFValue_value_startb>

  short marpaESLIFValue_value_startb(marpaESLIFValue_t *marpaESLIFValuep, int *startip);

Taken directly from L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper> interface, this is returning the Start Earleme Set Ids of current valuation phase in the value pointed by C<startip>, if the later is not C<NULL>. This should be used to produce progress reports if wanted.

This method cannot be called outside a valuation callback. C.f. C<marpaESLIFValue_value_lengthb> for an example.

Returns a true value on success, else a false value.

=head3 C<marpaESLIFValue_value_lengthb>

  short marpaESLIFValue_value_lengthb(marpaESLIFValue_t *marpaESLIFValuep, int *lengthip);

Returns the number of Earleme Set Ids in the value pointed by C<lengthip>, if the later is not C<NULL>.

The length is greater than zero only when current Start Earleme Set Id is at a non-nullable symbol. This method cannot be called outside a valuation callback.

A typical usage example is:

  int starti;
  int lengthi;

  if (marpaESLIFValue_value_startb(marpaESLIFValuep, &starti) &&
      marpaESLIFValue_value_lengthb(marpaESLIFValuep, &lengthi)) {
      marpaESLIFRecognizer_progressLogb(marpaESLIFValue_recognizerp(marpaESLIFValuep),
                                        starti,
                                        /* lengthi is zero when this is a nullable symbol */
                                        (lengthi > 0) ? starti+lengthi-1 : starti,
                                        GENERICLOGGER_LOGLEVEL_ERROR);
    }

Returns a true value on success, else a false value.

=head3 C<marpaESLIFValue_contextb>

  short marpaESLIFValue_contextb(marpaESLIFValue_t  *marpaESLIFValuep,
                                 char              **symbolsp,
                                 char               *rulesp);

Puts in the value pointed by C<symbolsp> if it is not C<NULL>, the current symbol name if valuation occurs on a symbol, or in the value pointed by C<rulesp> if it is not C<NULL>, the current current rule name if valuation occurs on a rule.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFValue_freev>

  void marpaESLIFValue_freev(marpaESLIFValue_t *marpaESLIFValuep);

The destructor of a marpaESLIFValue instance C<marpaESLIFValuep> instance. No-op if C<marpaESLIFValuep> is C<NULL>.

=head2 Stack manipulation

In the valuation callbacks, stack is manipulated using the functions described below. With no exception, they all return a true value on success, a false value on failure, and all have in common current marpaESLIF valuation context C<marpaESLIFValuep>.

The I<getAndForget> versions are dangerous in the sense that there is a risk of memory leak if your application forget to free a memory popped from the stack with such method. Nevertheless, they are also very handy when wou I<know> this is a pointer that should be, for example, embedded in another composite structure. The marpaESLIF internal bootstrap is using that.

=head3 C<marpaESLIFValue_stack_set_undefb>

  short marpaESLIFValue_stack_set_undefb(marpaESLIFValue_t *marpaESLIFValuep,
                                         int                indicei);

Puts the undefined value at stack number C<indicei>.

=head3 C<marpaESLIFValue_stack_set_charb>

  short marpaESLIFValue_stack_set_charb(marpaESLIFValue_t *marpaESLIFValuep,
                                        int                indicei,
                                        int                contexti,
                                        char               c);

Puts the C<C>'s C<char> value C<c>, associated to context C<contexti> that must be different than zero, at stack number C<indicei>.

=head3 C<marpaESLIFValue_stack_set_shortb>

  short marpaESLIFValue_stack_set_shortb(marpaESLIFValue_t *marpaESLIFValuep,
                                         int                indicei,
                                         int                contexti,
                                         short              b);

Puts the C<C>'s C<short> value C<b>, associated to context C<contexti> that must be different than zero, at stack number C<indicei>.

=head3 C<marpaESLIFValue_stack_set_intb>

  short marpaESLIFValue_stack_set_intb(marpaESLIFValue_t *marpaESLIFValuep,
                                       int                indicei,
                                       int                contexti,
                                       int                i);

Puts the C<C>'s C<int> value C<i>, associated to context C<contexti> that must be different than zero, at stack number C<indicei>.

=head3 C<marpaESLIFValue_stack_set_longb>

  short marpaESLIFValue_stack_set_longb(marpaESLIFValue_t *marpaESLIFValuep,
                                        int                indicei,
                                        int                contexti,
                                        long               l);

Puts the C<C>'s C<long> value C<l>, associated to context C<contexti> that must be different than zero, at stack number C<indicei>.

=head3 C<marpaESLIFValue_stack_set_floatb>

  short marpaESLIFValue_stack_set_floatb(marpaESLIFValue_t *marpaESLIFValuep,
                                         int                indicei,
                                         int                contexti,
                                         float              f);

Puts the C<C>'s C<float> value C<f>, associated to context C<contexti> that must be different than zero, at stack number C<indicei>.

=head3 C<marpaESLIFValue_stack_set_doubleb>

  short marpaESLIFValue_stack_set_doubleb(marpaESLIFValue_t *marpaESLIFValuep,
                                          int                indicei,
                                          int                contexti,
                                          double             d);

Puts the C<C>'s C<double> value C<d>, associated to context C<contexti> that must be different than zero, at stack number C<indicei>.

=head3 C<marpaESLIFValue_stack_set_ptrb>

  short marpaESLIFValue_stack_set_ptrb(marpaESLIFValue_t *marpaESLIFValuep,
                                       int                indicei,
                                       int                contexti,
                                       void              *p,
                                       short              shallowb);

Puts the C<C>'s Cvoid *> value C<p>, associated to context C<contexti> that must be different than zero, at stack number C<indicei>. I<If> C<shallowb> is a true value, then marpaESLIF will I<not> call a free callback on it.

=head3 C<marpaESLIFValue_stack_set_arrayb>

  short marpaESLIFValue_stack_set_arrayb(marpaESLIFValue_t *marpaESLIFValuep,
                                         int                indicei,
                                         int                contexti,
                                         void              *p,
                                         size_t             l,
                                         short shallowb);

Puts the C<C>'s Cvoid *> value C<p>, associated to context C<contexti> that must be different than zero and size C<l>, at stack number C<indicei>. I<If> C<shallowb> is a true value, then marpaESLIF will I<not> call a free callback on it.

=head3 C<marpaESLIFValue_stack_forgetb>

  short marpaESLIFValue_stack_forgetb(marpaESLIFValue_t *marpaESLIFValuep,
                                      int                indicei);

Says to marpaESLIF that he must forget about what it as indice C<indicei> in the stack. In such a case, internally, marpaESLIF is putting a sort of undefined value at this indice, though something that has nothing to do with what C<marpaESLIFValue_stack_set_undefb> is doing, the later being a user explicit wanted value type.

=head3 C<marpaESLIFValue_stack_get_contextb>

  short marpaESLIFValue_stack_get_contextb(marpaESLIFValue_t *marpaESLIFValuep,
                                           int                indicei,
                                           int               *contextip);

Returns the context associated to stack at indice C<indicei>. The value is C<0> when this is a context not managed by the end user.

=head3 C<marpaESLIFValue_stack_is_undefb>

  short marpaESLIFValue_stack_is_undefb(marpaESLIFValue_t *marpaESLIFValuep,
                                        int                indicei,
                                        short             *undefbp);

Puts in C<undefbp>, if it is not C<NULL>, a true value if stack at indice C<indice> is an undefined value, as per C<marpaESLIFValue_stack_set_undefb>.

=head3 C<marpaESLIFValue_stack_is_charb>

  short marpaESLIFValue_stack_is_charb(marpaESLIFValue_t *marpaESLIFValuep,
                                       int                indicei,
                                       short             *charbp);

Puts in C<charbp>, if it is not C<NULL>, a true value if stack at indice C<indice> is a C<C>'s C<char> value, as per C<marpaESLIFValue_stack_set_charb>.

=head3 C<marpaESLIFValue_stack_is_shortb>

  short marpaESLIFValue_stack_is_shortb(marpaESLIFValue_t *marpaESLIFValuep,
                                        int                indicei,
                                        short             *shortbp);

Puts in C<shortbp>, if it is not C<NULL>, a true value if stack at indice C<indice> is a C<C>'s C<short> value, as per C<marpaESLIFValue_stack_set_shortb>.

=head3 C<marpaESLIFValue_stack_is_intb>

  short marpaESLIFValue_stack_is_intb(marpaESLIFValue_t *marpaESLIFValuep,
                                      int                indicei,
                                      short             *intbp);

Puts in C<intbp>, if it is not C<NULL>, a true value if stack at indice C<indice> is a C<C>'s C<int> value, as per C<marpaESLIFValue_stack_set_intb>.

=head3 C<marpaESLIFValue_stack_is_longb>

  short marpaESLIFValue_stack_is_longb(marpaESLIFValue_t *marpaESLIFValuep,
                                       int                indicei,
                                       short             *longbp);

Puts in C<longbp>, if it is not C<NULL>, a true value if stack at indice C<indice> is a C<C>'s C<long> value, as per C<marpaESLIFValue_stack_set_longb>.

=head3 C<marpaESLIFValue_stack_is_floatb>

  short marpaESLIFValue_stack_is_floatb(marpaESLIFValue_t *marpaESLIFValuep,
                                        int                indicei,
                                        short             *floatbp);

Puts in C<floatbp>, if it is not C<NULL>, a true value if stack at indice C<indice> is a C<C>'s C<float> value, as per C<marpaESLIFValue_stack_set_floatb>.

=head3 C<marpaESLIFValue_stack_is_doubleb>

  short marpaESLIFValue_stack_is_doubleb(marpaESLIFValue_t *marpaESLIFValuep,
                                         int                indicei,
                                         short             *doublebp);

Puts in C<doublebp>, if it is not C<NULL>, a true value if stack at indice C<indice> is a C<C>'s C<double> value, as per C<marpaESLIFValue_stack_set_doubleb>.

=head3 C<marpaESLIFValue_stack_is_ptrb>

  short marpaESLIFValue_stack_is_ptrb(marpaESLIFValue_t *marpaESLIFValuep,
                                      int                indicei,
                                      short             *ptrbp);

Puts in C<ptrbp>, if it is not C<NULL>, a true value if stack at indice C<indice> is a C<C>'s C<ptr> value, as per C<marpaESLIFValue_stack_set_ptrb>.

=head3 C<marpaESLIFValue_stack_is_arrayb>

  short marpaESLIFValue_stack_is_arrayb(marpaESLIFValue_t *marpaESLIFValuep,
                                        int                indicei,
                                        short             *arraybp);

Puts in C<arraybp>, if it is not C<NULL>, a true value if stack at indice C<indice> is a C<C>'s C<array> value, as per C<marpaESLIFValue_stack_set_arrayb>.

=head3 C<marpaESLIFValue_stack_get_charb>

  short marpaESLIFValue_stack_get_charb(marpaESLIFValue_t *marpaESLIFValuep,
                                        int                indicei,
                                        int               *contextip,
                                        char              *cp);

Get in the value pointed by C<cp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<char> value and current context at stack indice C<indicei>.

=head3 C<marpaESLIFValue_stack_get_shortb>

  short marpaESLIFValue_stack_get_shortb(marpaESLIFValue_t *marpaESLIFValuep,
                                         int                indicei,
                                         int               *contextip,
                                         short             *bp);

Get in the value pointed by C<bp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<short> value and current context at stack indice C<indicei>.

=head3 C<marpaESLIFValue_stack_get_intb>

  short marpaESLIFValue_stack_get_intb(marpaESLIFValue_t *marpaESLIFValuep,
                                       int                indicei,
                                       int               *contextip,
                                       int               *ip);

Get in the value pointed by C<ip>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<int> value and current context at stack indice C<indicei>.

=head3 C<marpaESLIFValue_stack_get_longb>

  short marpaESLIFValue_stack_get_longb(marpaESLIFValue_t *marpaESLIFValuep,
                                        int                indicei,
                                        int               *contextip,
                                        long              *lp);

Get in the value pointed by C<lp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<long> value and current context at stack indice C<indicei>.

=head3 C<marpaESLIFValue_stack_get_floatb>

  short marpaESLIFValue_stack_get_floatb(marpaESLIFValue_t *marpaESLIFValuep,
                                         int                indicei,
                                         int               *contextip,
                                         float             *fp);

Get in the value pointed by C<fp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<float> value and current context at stack indice C<indicei>.

=head3 C<marpaESLIFValue_stack_get_doubleb>

  short marpaESLIFValue_stack_get_doubleb(marpaESLIFValue_t *marpaESLIFValuep,
                                          int                indicei,
                                          int               *contextip,
                                          double            *dp);

Get in the value pointed by C<dp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<double> value and current context at stack indice C<indicei>.

=head3 C<marpaESLIFValue_stack_get_ptrb>

  short marpaESLIFValue_stack_get_ptrb(marpaESLIFValue_t  *marpaESLIFValuep,
                                       int                 indicei,
                                       int                *contextip,
                                       void              **pp,
                                       short              *shallowbp);

Get in the value pointed by C<pp>, if it is not C<NULL>, in the value pointed by C<contextip> if it not C<NULL>, and in the value pointed by C<shallowbp> if it is not C<NULL>, the current C<C>'s C<void *> value, current context at stack indice C<indicei> and current shallow flag, respectively.

=head3 C<marpaESLIFValue_stack_get_arrayb>

  short marpaESLIFValue_stack_get_arrayb(marpaESLIFValue_t  *marpaESLIFValuep,
                                       int                   indicei,
                                       int                  *contextip,
                                       void                **pp,
                                       size_t               *lp,
                                       short                *shallowbp);

Get in the value pointed by C<pp>, if it is not C<NULL>, in the value pointed by C<contextip> if it not C<NULL>, in the value pointed by C<lp> if it is not C<NULL> and in the value pointed by C<shallowbp> if it is not C<NULL>, the current C<C>'s C<void *> value, the current context at stack indice C<indicei>, the associated C<C>'s C<size_t> value > and current shallow flag, respectively.

=head3 C<marpaESLIFValue_stack_getAndForget_charb>

  short marpaESLIFValue_stack_getAndForget_charb(marpaESLIFValue_t *marpaESLIFValuep,
                                                 int                indicei,
                                                 int               *contextip,
                                                 char              *cp);

Get in the value pointed by C<cp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<char> value and current context at stack indice C<indicei>. marpaESLIF will then forget about it. User's responsibility to know what he is doing.

=head3 C<marpaESLIFValue_stack_getAndForget_shortb>

  short marpaESLIFValue_stack_getAndForget_shortb(marpaESLIFValue_t *marpaESLIFValuep,
                                                  int                indicei,
                                                  int               *contextip,
                                                  short             *bp);

Get in the value pointed by C<bp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<short> value and current context at stack indice C<indicei>. marpaESLIF will then forget about it. User's responsibility to know what he is doing.

=head3 C<marpaESLIFValue_stack_getAndForget_intb>

  short marpaESLIFValue_stack_getAndForget_intb(marpaESLIFValue_t *marpaESLIFValuep,
                                                int                indicei,
                                                int               *contextip,
                                                int               *ip);

Get in the value pointed by C<ip>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<int> value and current context at stack indice C<indicei>. marpaESLIF will then forget about it. User's responsibility to know what he is doing.

=head3 C<marpaESLIFValue_stack_getAndForget_longb>

  short marpaESLIFValue_stack_getAndForget_longb(marpaESLIFValue_t *marpaESLIFValuep,
                                                 int                indicei,
                                                 int               *contextip,
                                                 long              *lp);

Get in the value pointed by C<lp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<long> value and current context at stack indice C<indicei>. marpaESLIF will then forget about it. User's responsibility to know what he is doing.

=head3 C<marpaESLIFValue_stack_getAndForget_floatb>

  short marpaESLIFValue_stack_getAndForget_floatb(marpaESLIFValue_t *marpaESLIFValuep,
                                                  int                indicei,
                                                  int               *contextip,
                                                  float             *fp);

Get in the value pointed by C<fp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<float> value and current context at stack indice C<indicei>. marpaESLIF will then forget about it. User's responsibility to know what he is doing.

=head3 C<marpaESLIFValue_stack_getAndForget_doubleb>

  short marpaESLIFValue_stack_getAndForget_doubleb(marpaESLIFValue_t *marpaESLIFValuep,
                                                   int                indicei,
                                                   int               *contextip,
                                                   double            *dp);

Get in the value pointed by C<dp>, if it is not C<NULL>, and in the value pointed by C<contextip> if it not C<NULL>, the current C<C>'s C<double> value and current context at stack indice C<indicei>. marpaESLIF will then forget about it. User's responsibility to know what he is doing.

=head3 C<marpaESLIFValue_stack_getAndForget_ptrb>

  short marpaESLIFValue_stack_getAndForget_ptrb(marpaESLIFValue_t  *marpaESLIFValuep,
                                                int                 indicei,
                                                int                *contextip,
                                                void              **pp,
                                                short              *shallowbp);

Get in the value pointed by C<pp>, if it is not C<NULL>, in the value pointed by C<contextip> if it not C<NULL>, and in the value pointed by C<shallowbp> if it is not C<NULL>, the current C<C>'s C<void *> value, current context at stack indice C<indicei> and current shallow flag, respectively. marpaESLIF will then forget about it. User's responsibility to know what he is doing. User's responsibility to manage pointer value if this has been allocated on the heap.

=head3 C<marpaESLIFValue_stack_getAndForget_arrayb>

  short marpaESLIFValue_stack_getAndForget_arrayb(marpaESLIFValue_t  *marpaESLIFValuep,
                                                int                   indicei,
                                                int                  *contextip,
                                                void                **pp,
                                                size_t               *lp,
                                                short                *shallowbp);

Get in the value pointed by C<pp>, if it is not C<NULL>, in the value pointed by C<contextip> if it not C<NULL>, in the value pointed by C<lp> if it is not C<NULL> and in the value pointed by C<shallowbp> if it is not C<NULL>, the current C<C>'s C<void *> value, the current context at stack indice C<indicei>, the associated C<C>'s C<size_t> value > and current shallow flag, respectively. User's responsibility to manage pointer value if this has been allocated on the heap.

=head1 NOTES

=over

=item Thread-safety

Any of the object of this API is thread-safe but is not I<reentrant>. That is, if user need to access the same object from different threads, he is responsible of doing sychronization.

=item Grammar show form

The grammar show form is a concatenation of rule show forms and internal information, for every valid grammar level. For every grammar, the following is outputed:

=over

=item Meta grammar settings

For example:

  /*
   * **********************
   * Meta-grammar settings:
   * **********************
   */
  :start ::= json
  :default ::= action => ::concat
               symbol-action => ::shift
               latm => 1

=item Event settings

For example:

  /*
   * ***************
   * Event settings:
   * ***************
   */
  :lexeme ::= <lstring> pause => after event => lstring$=on

=item Rules

For example:

  /*
   * ******
   * Rules:
   * ******
   */
  <json> ::= <object>
  <json> ::= <array>
  <object> ::= '{' <members> '}' action => do_object
  etc...

=item Lexemes

A I<lexeme> is a symbol that is referencing another symbol of the same name but in <another> grammar level, for example:

  # --------
  # Lexemes:
  # --------
  #
  # <number> ::= <number>@+1
  # <lstring> ::= <lstring>@+1
  # <whitespace> ::= <whitespace>@+1

=item Rule properties

For every rule, Marpa parser internal properties are given, together with the rule description, and components of the rule in terms in symbol indices, for example:

  # -----------------
  # Rules properties:
  # -----------------
  #
  # Rule No 0
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <json> ::= <object>
  #   Components:  LHS = RHS[]
  #                  0 = 1
  # ...
  #
  # Rule No 2
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <object> ::= '{' <members> '}' action => do_object
  #   Components:  LHS = RHS[]
  #                  1 = 3 4 5
  # Rule No 3
  #   Properties: ACCESSIBLE, NULLABLE, PRODUCTIVE
  #   Definition: <members> ::= <pair>* separator => /[,]/ action => do_array
  #   Components:  LHS = RHS[]
  #                  4 = 6
  #
  # ...

Exceptions are shown like this:

  #
  # Rule No 2
  #   Properties: ACCESSIBLE, NULLABLE, PRODUCTIVE
  #   Definition: <start> ::= <thisstart> - <startException>
  #   Components:  LHS = RHS[] - EXCEPTION
  #                  0 = 4 - 5
  #

=item Symbol properties

For every symbol, its ESLIF type, Marpa parser properties and definition are given. When it is a terminal, corresponding regular expression definition is given, as well as eventual JIT usage (c.f. PCRE2 information to understand what it is about). For example:

  # -------------------
  # Symbols properties:
  # -------------------
  #
  # Symbol No 0
  #         Type: ESLIF META
  #   Properties: ACCESSIBLE, PRODUCTIVE, START
  #         Name: <json>
  #
  # ...
  #
  # Symbol No 3
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: \{
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # ...
  #
  # Symbol No 23
  #         Type: ESLIF TERMINAL
  #   Properties: PRODUCTIVE, TERMINAL
  #      Pattern:
  #     0x000000: 5b 5c 73 5d                                     [\s]
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes

There are two types of terminal:

=over

=item Strings

Strings are always converted to a pattern that is fully ASCII compatible, in which ESLIF decide to eventually escape some characters, or to use them in their C<\x{...}> code point version. Therefore the definition of the PCRE2 pattern is outputed as-is.

=item Regular expression

This type include character class. In such a case, the UTF-8 byte sequence corresponding to what the grammar is defining is sent directly to PCRE2, so the definition is the dump of this UTF-8 byte sequence.

=back

=back

=back

=head1 SEE ALSO

L<genericLogger|https://github.com/jddurand/c-genericLogger>,  L<PCRE2|http://www.pcre.org/>, L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html>, L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>
