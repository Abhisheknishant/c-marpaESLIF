=encoding UTF-8

=head1 NAME

marpaESLIF_API - Extended Marpa's Scanless Interface API

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

The whole API is available with this include:

  #include <marpaESLIF.h>

There are four namespaces:

=over

=item ESLIF

The main object.

=item ESLIFGrammar

Grammar creation and inspection.

=item ESLIFRecognizer

Parsing phase.

=item ESLIFValue

Valuation phase.

=back

and on transversal type:

  typedef struct marpaESLIFString {
    char   *bytep;            /* pointer bytes */
    size_t  bytel;            /* number of bytes */
    char   *encodingasciis;   /* Encoding of bytes, itself in ASCII encoding, NUL byte terminated */
    char   *asciis;           /* ASCII transliteration - never NULL if bytep is not NULL */
  } marpaESLIFString_t;

which describe what is a I<string>: this is a sequence of C<bytel> bytes, starting at C<bytep> in memory, in eventual C<encodingasciis> encoding, and transliterated into C<asciis>.

=head2 ESLIF

=head3 C<marpaESLIF_newp>

  typedef struct marpaESLIFOption {
    genericLogger_t *genericLoggerp;  /* Logger. Default: NULL */
  } marpaESLIFOption_t;

  marpaESLIF_t *marpaESLIF_newp(marpaESLIFOption_t *marpaESLIFOptionp);

Any application must start by instanciating a main ESLIF. This method is returning such a main C<marpaESLIF> object, or C<NULL> is failure, using C<marpaESLIFOptionp> that is an eventual pointer to a C<marpaESLIFOption_t> structure. This structure contain:

=over

=item C<genericLoggerp>

A pointer to a C<genericLogger_t> instance. If it is NULL, then C<marpaESLIF> instance, neither any of the other namespaces, will do logging. Otherwise, all will inherit this logger object and use it.

=back

=head3 C<marpaESLIF_freev>

  void marpaESLIF_freev(marpaESLIF_t *marpaESLIFp);

The C<marpaESLIF> destructor, with parameter C<marpaESLIFp> being an instance previously created. No-op if C<marpaESLIFp> is NULL.

=head2 ESLIFGrammar

An I<ESLIFGrammar> is an array of grammars, each identified by a I<level>, that is the indice in this array. Most of the APIs in this section have a version to deal with I<current> grammar, and a version for the grammar at a wanted I<indice> or I<description>.
The default current grammar is always at level C<0>, nevertheless it is possible to instanciate a parsing at a different level, and if, as a use case, you are sharing the same actions between different levels, this is the way to know in I<which grammar> you are.

=head3 C<marpaESLIFGrammar_newp>

  typedef struct marpaESLIFGrammarOption {
    void   *bytep;               /* Input */
    size_t  bytel;               /* Input length in byte unit */
    char   *encodings;           /* Input encoding. Default: NULL */
    size_t  encodingl;           /* Length of encoding itself. Default: 0 */
    char   *encodingOfEncodings; /* Encoding of encoding, in ASCII encoding. Default: NULL. */
  } marpaESLIFGrammarOption_t;

  marpaESLIFGrammar_t *marpaESLIFGrammar_newp(marpaESLIF_t              *marpaESLIFp,
                                              marpaESLIFGrammarOption_t *marpaESLIFGrammarOptionp);

This is creating a grammar object instance, with parameters:

=over

=item C<marpaESLIFp>

Object instance of the main ESLIF.

=item C<marpaESLIFGrammarOptionp>

Required pointer to a C<marpaESLIFGrammarOption_t> structure, that contain:

=over

=item C<bytep>

A pointer to the start of the grammar. Must be non-NULL.

=item C<bytel>

Number of bytes. Must be > 0.

=item C<encodings>

Pointer to a buffer containing encoding information of the grammar. Can be NULL.

=item C<encodingl>

Number of bytes of the buffer containing encoding information. Can be 0.

=item C<encodingOfEncodings>

ASCII and NUL-terminated string giving the encoding of the encoding information itself. Can be NULL.

=back

=back

In real life-programming, grammars are assumed to always fit within a single block of memory. So there is no reader of grammar definition, we assume that C<bytep> and C<bytel> are enough for this job.

Return C<NULL> if failure, a grammar object instance on success.

=head3 C<marpaESLIFGrammar_eslifp>

  marpaESLIF_t *marpaESLIFGrammar_eslifp(marpaESLIFGrammar_t *marpaESLIFGrammarp);

Return the main ESLIF object instance from a C<marpaESLIFGrammarp> ESLIFGrammar instance, or C<NULL> is failure.

=head3 C<marpaESLIFGrammar_ngrammarib>

  short marpaESLIFGrammar_ngrammarib(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                     int                 *ngrammarip);

Put the number of grammars in the value pointed by C<ngrammarip>, which can be C<NULL>, of the current grammar from C<marpaESLIFGrammarp>. The number of grammars is the highest level plus one, and it is B<allowed> to have undefined grammars at any indice but level 0.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammar_currentb>

  short marpaESLIFGrammar_grammar_currentb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                           int                 *levelip,
                                           marpaESLIFString_t **descpp);

Put in the values pointed by C<levelip> and C<descpp>, which can be both C<NULL>, the level and description of current grammar from C<marpaESLIFGrammarp>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammar_by_levelb>

  short marpaESLIFGrammar_grammar_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                            int                  leveli,
                                            marpaESLIFString_t  *descp,
                                            int                 *levelip,
                                            marpaESLIFString_t **descpp);

Put in the values pointed by C<levelip> and C<descpp>, which can be both C<NULL>, the level and description of wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_rulearray_currentb>

  short marpaESLIFGrammar_rulearray_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                             int                 **ruleipp,
                                             size_t               *rulelp);

Put in the values pointed by C<ruleipp> and C<rulelp> the rule indices and the number of such indices of current grammar from C<marpaESLIFGrammarp>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_rulearray_by_levelb>

  short marpaESLIFGrammar_rulearray_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                              int                 **ruleipp,
                                              size_t               *rulelp,
                                              int                   leveli,
                                              marpaESLIFString_t   *descp);


Put in the values pointed by C<ruleipp> and C<rulelp> the rule indices and the number of such indices of wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_ruledisplayform_currentb>

  short marpaESLIFGrammar_ruledisplayform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                   int                   rulei,
                                                   char                **ruledisplaysp);

Put in the value pointed by C<ruledisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of rule name at indice C<rulei> of the current grammar from C<marpaESLIFGrammarp>.

Return a true value on failure, a false value on failure.

Example of a rule display form:

  <lstring>

=head3 C<marpaESLIFGrammar_ruledisplayform_by_levelb>

  short marpaESLIFGrammar_ruledisplayform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   rulei,
                                                    char                **ruledisplaysp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<ruledisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of rule name at indice C<rulei> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_symboldisplayform_currentb>

  short marpaESLIFGrammar_symboldisplayform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                     int                   symboli,
                                                     char                **symboldisplaysp);

Put in the value pointed by C<symboldisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of symbol name at indice C<symboli> of the current grammar from C<marpaESLIFGrammarp>. C<symboli> is an argument of symbol actions (c.f. the documentation for actions).

Return a true value on failure, a false value on failure.

Example of a symbol display form:

  <in_string>

=head3 C<marpaESLIFGrammar_symboldisplayform_by_levelb>

  short marpaESLIFGrammar_symboldisplayform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                      int                   symboli,
                                                      char                **symboldisplaysp,
                                                      int                   leveli,
                                                      marpaESLIFString_t   *descp);

Put in the value pointed by C<symboldisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of symbol name at indice C<symboli> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>. C<symboli> is an argument of symbol actions (c.f. the documentation for actions).

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_ruleshowform_currentb>

  short marpaESLIFGrammar_ruleshowform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                int                   rulei,
                                                char                **ruleshowsp);

Put in the value pointed by C<ruleshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of rule definition at indice C<rulei> of the current grammar from C<marpaESLIFGrammarp>.

Return a true value on failure, a false value on failure.

Example of a rule show form:

  <lstring> ~ <quote> <in_string> <quote>

=head3 C<marpaESLIFGrammar_ruleshowform_by_levelb>

  short marpaESLIFGrammar_ruleshowform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   rulei,
                                                    char                **ruleshowsp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<ruleshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of rule definition at indice C<rulei> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarshowform_currentb>

  short marpaESLIFGrammar_grammarshowform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                   int                   grammari,
                                                   char                **grammarshowsp);

Put in the value pointed by C<grammarshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of grammar definition at indice C<grammari> of the current grammar from C<marpaESLIFGrammarp>. This is very exhaustive, and give internal information about all symbols and rules. See the NOTES section.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarshowform_by_levelb>

  short marpaESLIFGrammar_grammarshowform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   grammari,
                                                    char                **grammarshowsp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<grammarshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of grammar definition at indice C<grammari> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

This is very exhaustive, and give internal information about all symbols and rules. See the NOTES section.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_parseb>

  short marpaESLIFGrammar_parseb(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                 marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp,
                                 marpaESLIFValueOption_t      *marpaESLIFValueOptionp,
                                 short                        *exhaustedbp,
                                 marpaESLIFValueResult_t      *marpaESLIFValueResultp);

Please refer to the documentation of:

=over

=item C<marpaESLIFGrammar_newp>

for the C<marpaESLIFRecognizerOption_t> structure documentation.

=item C<marpaESLIFValue_newp>

for the C<marpaESLIFValueOption_t> and C<marpaESLIFValueResult_t> structures documentation.

=back

A short form of parsing and valuation, in which I<no event> is possible: the entire scanning is left to the marpaESLIF engine. The grammar at level C<0> is used.

The value pointed by C<exhaustedbp>, when not C<NULL>, is filled with a true value if the parsing exhausted (exhaustion roughly mean that the parsing stopped without consuming all the data), a false value otherwise.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIFGrammar_parse_by_levelb>

  short marpaESLIFGrammar_parse_by_levelb(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                          marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp,
                                          marpaESLIFValueOption_t      *marpaESLIFValueOptionp,
                                          short                        *exhaustedbp,
                                          int                           leveli,
                                          marpaESLIFString_t           *descp,
                                          marpaESLIFValueResult_t      *marpaESLIFValueResultp);

Same functionnality as C<marpaESLIFGrammar_parseb> for a wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

=head3 C<marpaESLIFGrammar_freev>

  void marpaESLIFGrammar_freev(marpaESLIFGrammar_t *marpaESLIFGrammarp);

The destructor of a C<marpaESLIFGrammarp> instance. No-op if C<marpaESLIFGrammarp> is C<NULL>.

=head2 ESLIFRecognizer

=head3 C<marpaESLIFRecognizer_newp>

  typedef short (*marpaESLIFReader_t)(void    *userDatavp,
                                      char   **inputcpp,
                                      size_t  *inputlp,
                                      short   *eofbp,
                                      short   *characterStreambp,
                                      char   **encodingOfEncodingsp,
                                      char   **encodingsp,
                                      size_t  *encodinglp);
  typedef struct marpaESLIFRecognizerOption {
    void                *userDatavp;                  /* User specific context */
    marpaESLIFReader_t   marpaESLIFReaderCallbackp;   /* Reader callback */
    short                disableThresholdb;           /* Disable threshold warning.  Recommended: 0 */
    short                exhaustedb;                  /* Exhaustion event.           Recommended: 0 */
    short                newlineb;                    /* Count line/column numbers.  Recommended: 0 */
    size_t               bufsizl;                     /* Minimum stream buffer size. Recommended: 0 */

    /* Excess number of bytes, in % of bufsizl, where stream buffer size is reduced */
    unsigned int         buftriggerperci;             /*                             Recommended: 50 */

    /* Policy of minimum of bytes for increase, in % of current allocated size, when */
    /*  stream buffer size need to augment */
    unsigned int         bufaddperci;                 /*                             Recommended: 50 */
  } marpaESLIFRecognizerOption_t;

  marpaESLIFRecognizer_t *marpaESLIFRecognizer_newp(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                                    marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp);

Creates a recognizer out of a C<marpaESLIFGrammarp> grammar instance.

The C<marpaESLIFReader_t> defines the prototype of a reader, referenced in the required parameter C<marpaESLIFRecognizerOptionp>. Its arguments are:

=over

=item C<userDatavp>

User opaque pointer, set in C<marpaESLIFRecognizerOptionp> and propagated as-is to the reader. There is no default value.

=item C<inputcpp>

The place where the user will set the pointer of the next available buffer. Default is C<NULL>.

=item C<inputlp>

The place where the user will set the number of bytes of the next available buffer. Default is C<0>.

=item C<eofbp>

The place where the user will set a flag saying this the end of data. Default is a false value.

=item C<characterStreambp>

The place where the user will set a flag saying this buffer I<must> be a stream of characters. Default is a false value.

=item C<encodingOfEncodingsp>

The place where the user will give in which encoding is the encoding itself. Default is <NULL>.

=item C<encodingsp>

The place where the user will give a pointer to a buffer containing encoding information, encoded using C<encodingOfEncodingsp> encoding. Default is C<NULL>.

=item C<encodinglp>

The place where the user will give a size of the buffer starting at C<*encodingsp>. Default is C<0>.

=back

Mixing binary and character streams is possible but only at the chunk level, where a chunk is the data buffer returned by the reader callback. It is up the user to be able to determine the boundaries. Here is how the character stream flag and encoding information is used by marpaESLIF at the return of the reader callback:

=over

=item 1 - User say this is a character stream

=over

=item A - Previous read was also a character streams

=over

=item a - User gave encoding (C<*encodingsp> is not C<NULL>)

If previous encoding is different, it is flushed and a new one is starting. Else previous encoding continue, this more will support incomplete character from the previous chunk.

=item b - User gave no encoding (C<*encodingsp> is C<NULL>)

It is assumed that previous encoding continue

=back

=item B - Previous read was not a stream of characters (or there was no previous read)

If user gave encoding information it is used, else encoding is guessed.

=back

=item 2 - User say this is not a character stream

=over

=item A - Previous read was a character stream

It is flushed, and binary data is appended as-is.

=item B - Previous read was not a character stream (or there was no previous read)

Binary data is appended as-is.

=back

=back

I<If> the grammar requires UTF-8 understanding of the buffer (either by using characters with code points greater than C<0xFF> in terminals, or explicitely setting the C<c> modifier to regular expressions - all of that meaning that PCRE2 expressions have the PCRE2_UTF flag), and C<If> the chunk of data was not declared as a character stream: it is assumed that it is in UTF-8 encoding. PCRE2 will check that and yell if it does not contain only valid UTF-8 characters.

The parameter C<marpaESLIFRecognizerOptionp> is a pointer to a C<marpaESLIFRecognizerOption_t> structure, where:

=over

=item C<userDatavp>

User context, propagated as-is to reader callback.

=item C<marpaESLIFReaderCallbackp>

Pointer to the reader callback. Must not be C<NULL>.

=item C<disableThresholdb>

Disable treshold warning generated by L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html>. Recommended value is a false value, because when such warning arises, it usually indicate some problem with the grammar.

=item C<exhaustedb>

Support of exhaustion. Recommended value is a false value, because the most common usage of parsing data is to parse the full buffer up to its end of data. Nevertheless is is quite easy to find applications that support the exhaustion, for example parsing of binary structures that contain sub-structures, and so on.

=item C<newlineb>

Support of newline count. This is used when the parser fails to produce ab accurate report with line and number information. Works at the granularity of data chunk, and is meaningless if data chunk is not declared as a character stream. Any Unicode line ending sequence is considered.

=item C<bufsizl>

Default number of bytes of the internal buffer in marpaESLIF, in which I<all> data is stored and appended. If C<0>, the value used when compiling marpaESLIF library is used, itself defaulting to 1Mb. Recommended value is C<0>.

=item C<buftriggerperci>

In order to prevent internal buffer to grow indefinitely, C<buftriggerperci> is the percentage of C<bufsizl> that give a trigger on the number of unused bytes at which the internal buffer is reduced to its initial size C<bufsizl>. Recommended value is C<50>.

=item C<bufaddperci>

To prevent too many memory allocations, when marpaESLIF need to increase its internal buffer, it will do so by requesting C<bufaddperci> percent of current allocated size more bytes. Recommended value: C<50>.

=back

This method returns a recognizer pointer in case of success, C<NULL> in case of failure.

=head3 C<marpaESLIFRecognizer_grammarp>

  marpaESLIFGrammar_t *marpaESLIFRecognizer_grammarp(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

Returns the ESLIFGrammar instance parent of the C<marpaESLIFRecognizerp> instance, C<NULL> in case of failure.

=head3 C<marpaESLIFRecognizer_scanb>

  short marpaESLIFRecognizer_scanb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                   short initialEventsb,
                                   short *continuebp,
                                   short *exhaustedbp);

Start a scanless parsing using the C<marpaESLIFRecognizerp> instance. Only one such call can be done in the whole lifetime of a recognizer. Parameters are:

=over

=item initialEventsb

Traditionnally initial events are not of use and are skipped. When true, this flag enable such events.

=item continuebp

The scanning will pause as soon as there is an event or an error. When not C<NULL>, the value pointed by C<continuebp> say that if scanning can continue if it is a true value.

=item exhaustedbp

If not C<NULL>, this value pointed by C<exhaustedbp> will say if the parse is exhausted.

=back

A typical usage of the C<marpaESLIFRecognizer_scanb> method is:

  short continueb;
  short exhaustedb;

  if (! marpaESLIFRecognizer_scanb(marpaESLIFRecognizerp,
                                   0 /* initialEventsb */,
                                   &continueb,
                                   &exhaustedb)) {
    goto error_processing;
  }
  while (continueb) {
    /* See below for the events, pause and resume methods */
  }

This method returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_resumeb>

  short marpaESLIFRecognizer_resumeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                     short *continuebp,
                                     short *exhaustedbp);

Resume the scanning. All parameters have the same meaning as for C<marpaESLIFRecognizer_scanb>. A typical usage is:

  short continueb;
  short exhaustedb;

  if (! marpaESLIFRecognizer_scanb(marpaESLIFRecognizerp,
                                   0 /* initialEventsb */,
                                   &continueb,
                                   &exhaustedb)) {
    goto error_processing;
  }
  while (continueb) {
    /* See below for the events and pause */
    /* ... */
    /* Resume */
    if (! marpaESLIFRecognizer_resumeb(marpaESLIFRecognizerp,
                                       &continueb,
                                       &exhaustedb)) {
      goto error_processing;
    }
  }

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_alternative_lengthb>

  short marpaESLIFRecognizer_alternative_lengthb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                 size_t alternativeLengthl);

When a recognizer is paused, user have the possibility to inject himself symbols. The marpaESLIF does I<not> support injection of symbols that would be of different length in the input stream: all symbols will be of of size C<alternativeLengthl>, which is in I<byte> unit. At every pause of the scanning, this method can be called once, and it is illegal to give a length higher than the number of remaining bytes in marpaESLIF internal buffer (see the C<marpaESLIFRecognizer_readb> for injecting more data, and C<marpaESLIFRecognizer_inputv> for get information of the internal buffers).

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_alternativeb>

  short marpaESLIFRecognizer_alternativeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          char *symbols);

Say to the recognizer pointed by C<marpaESLIFRecognizerp> that symbol C<symbols> (which is an ASCII NUL terminated string) is an alternative.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_completeb>

  short marpaESLIFRecognizer_completeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

Say to the recognizer pointed C<marpaESLIFRecognizerp> by that the current set of alternatives is complete: these are the ones pushed with C<marpaESLIFRecognizer_alternativeb> method, and they all take the number of bytes in the input stream declared with C<marpaESLIFRecognizer_alternative_lengthb>.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_eofb>

  short marpaESLIFRecognizer_eofb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

Forces the recognizer pointed by C<marpaESLIFRecognizerp> to believe that the end of data is reached.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_event_onoffb>

  typedef enum marpaESLIFEventType {
    MARPAESLIF_EVENTTYPE_NONE       = 0x00,
    MARPAESLIF_EVENTTYPE_COMPLETED  = 0x01, /* Grammar event */
    MARPAESLIF_EVENTTYPE_NULLED     = 0x02, /* Grammar event */
    MARPAESLIF_EVENTTYPE_PREDICTED  = 0x04, /* Grammar event */
    MARPAESLIF_EVENTTYPE_BEFORE     = 0x08, /* Just before lexeme is commited */
    MARPAESLIF_EVENTTYPE_AFTER      = 0x10, /* Just after lexeme is commited */
    MARPAESLIF_EVENTTYPE_EXHAUSTED  = 0x20, /* Exhaustion */
    MARPAESLIF_EVENTTYPE_DISCARD    = 0x40  /* Discard */
  } marpaESLIFEventType_t;

  short marpaESLIFRecognizer_event_onoffb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          int                     symboli,
                                          marpaESLIFEventType_t   eventSeti,
                                          short                   onoffb);

Switches on or off the event types C<eventSeti> (which is a bit mask of event type), depending of C<onoffb> value, at symbol number C<symboli> of current grammar.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_expectedb>

  short marpaESLIFRecognizer_expectedb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                       size_t                 *nSymbollp,
                                       int                    **symbolArraypp);

=head1 NOTES

=over

=item Thread-safety

Any of the object of this API is thread-safe but is not I<reentrant>. That is, if user need to access the same object from different threads, he is responsible of doing sychronization.

=item Grammar show form

The grammar show form is a concatenation of rule show forms and internal information, for every valid grammar level. For every grammar, the following is outputed:

=over

=item Meta grammar settings

For example:

  /*
   * **********************
   * Meta-grammar settings:
   * **********************
   */
  :start ::= json
  :default ::= action => ::concat
               symbol-action => ::shift
               latm => 1

=item Event settings

For example:

  /*
   * ***************
   * Event settings:
   * ***************
   */
  :lexeme ::= <lstring> pause => after event => lstring$=on

=item Rules

For example:

  /*
   * ******
   * Rules:
   * ******
   */
  <json> ::= <object>
  <json> ::= <array>
  <object> ::= '{' <members> '}' action => do_object
  etc...

=item Lexemes

A I<lexeme> is a symbol that is referencing another symbol of the same name but in <another> grammar level, for example:

  # --------
  # Lexemes:
  # --------
  #
  # <number> ::= <number>@+1
  # <lstring> ::= <lstring>@+1
  # <whitespace> ::= <whitespace>@+1

=item Rule properties

For every rule, Marpa parser internal properties are given, together with the rule description, and components of the rule in terms in symbol indices, for example:

  # -----------------
  # Rules properties:
  # -----------------
  #
  # Rule No 0
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <json> ::= <object>
  #   Components:  LHS = RHS[]
  #                  0 = 1
  # ...
  #
  # Rule No 2
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <object> ::= '{' <members> '}' action => do_object
  #   Components:  LHS = RHS[]
  #                  1 = 3 4 5
  # Rule No 3
  #   Properties: ACCESSIBLE, NULLABLE, PRODUCTIVE
  #   Definition: <members> ::= <pair>* separator => /[,]/ action => do_array
  #   Components:  LHS = RHS[]
  #                  4 = 6
  #
  # ...

=item Symbol properties

For every symbol, its ESLIF type, Marpa parser properties and definition are given. When it is a terminal, corresponding regular expression definition is given, as well as eventual JIT usage (c.f. PCRE2 information to understand what it is about). For example:

  # -------------------
  # Symbols properties:
  # -------------------
  #
  # Symbol No 0
  #         Type: ESLIF META
  #   Properties: ACCESSIBLE, PRODUCTIVE, START
  #         Name: <json>
  #
  # ...
  #
  # Symbol No 3
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: \{
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # ...
  #
  # Symbol No 23
  #         Type: ESLIF TERMINAL
  #   Properties: PRODUCTIVE, TERMINAL
  #      Pattern:
  #     0x000000: 5b 5c 73 5d                                     [\s]
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes

There are two types of terminal:

=over

=item Strings

Strings are always converted to a pattern that is fully ASCII compatible, in which ESLIF decide to eventually escape some characters, or to use them in their C<\x{...}> code point version. Therefore the definition of the PCRE2 pattern is outputed as-is.

=item Regular expression

This type include character class. In such a case, the UTF-8 byte sequence corresponding to what the grammar is defining is sent directly to PCRE2, so the definition is the dump of this UTF-8 byte sequence.

=back

=back

=back

=head1 SEE ALSO

L<genericLogger|https://github.com/jddurand/c-genericLogger>,  L<PCRE2|http://www.pcre.org/>, L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html>
