=encoding UTF-8

=head1 NAME

marpaESLIF_API - Extended Marpa's Scanless Interface API

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

The whole API is available with this include:

  #include <marpaESLIF.h>

There are four namespaces:

=over

=item ESLIF

The main object.

=item ESLIFGrammar

Grammar creation and inspection.

=item ESLIFRecognizer

Parsing phase.

=item ESLIFValue

Valuation phase.

=back

and on transversal type:

  typedef struct marpaESLIFString {
    char   *bytep;            /* pointer bytes */
    size_t  bytel;            /* number of bytes */
    char   *encodingasciis;   /* Encoding of bytes, itself being writen in ASCII encoding, NUL byte terminated */
    char   *asciis;           /* ASCII (un-translatable bytes are changed to a replacement character) translation of previous bytes, NUL byte terminated - never NULL if bytep is not NULL */
    /*
     * Remark: the encodings and asciis pointers are not NULL only when ESLIF know that the buffer is associated to a "description". I.e.
     * this is happening ONLY when parsing the grammar. Raw data never have non-NULL asciis or encodings.
     */
  } marpaESLIFString_t;

which describe what is a I<string>: this is a sequence of C<bytel> bytes, starting at C<bytep> in memory, in eventual C<encodingasciis> encoding, and transliterated into C<asciis>.

=head2 ESLIF

=head3 marpaESLIF_newp

  typedef struct marpaESLIFOption {
    genericLogger_t *genericLoggerp;  /* Logger. Default: NULL */
  } marpaESLIFOption_t;

  marpaESLIF_t           *marpaESLIF_newp(marpaESLIFOption_t *marpaESLIFOptionp);

Any application must start by instanciating a main ESLIF. This method is returning such a main C<marpaESLIF> object, or C<NULL> is failure, using C<marpaESLIFOptionp> that is an eventual pointer to a C<marpaESLIFOption_t> structure. This structure contain:

=over

=item genericLoggerp

A pointer to a C<genericLogger_t> instance. If it is NULL, then C<marpaESLIF> instance, neither any of the other namespaces, will do logging. Otherwise, all will inherit this logger object and use it.

=back

=head3 marpaESLIF_freev

  void                    marpaESLIF_freev(marpaESLIF_t *marpaESLIFp);

The C<marpaESLIF> destructor, with parameter C<marpaESLIFp> being an instance previously created.

=head2 ESLIFGrammar

=head3 marpaESLIFGrammar_newp

  typedef struct marpaESLIFGrammarOption {
    void   *bytep;               /* Input */
    size_t  bytel;               /* Input length in byte unit */
    char   *encodings;           /* Input encoding. Default: NULL */
    size_t  encodingl;           /* Length of encoding itself. Default: 0 */
    char   *encodingOfEncodings; /* Encoding of encoding, in ASCII encoding. Default: NULL. */
  } marpaESLIFGrammarOption_t;

  marpaESLIFGrammar_t    *marpaESLIFGrammar_newp(marpaESLIF_t *marpaESLIFp,
                                                 marpaESLIFGrammarOption_t *marpaESLIFGrammarOptionp);

This is creating a grammar object instance, with parameters:

=over

=item C<marpaESLIFp>

Object instance of the main ESLIF.

=item C<marpaESLIFGrammarOptionp>

Required pointer to a C<marpaESLIFGrammarOption_t> structure, that contain:

=over

=item C<bytep>

A pointer to the start of the grammar. Must be non-NULL.

=item C<bytel>

Number of bytes. Must be > 0.

=item C<encodings>

Pointer to a buffer containing encoding information of the grammar. Can be NULL.

=item C<encodingl>

Number of bytes of the buffer containing encoding information. Can be 0.

=item C<encodingOfEncodings>

ASCII and NUL-terminated string giving the encoding of the encoding information itself. Can be NULL.

=back

In real life-programming, grammars are assumed to always fit within a single block of memory. So there is no reader of grammar definition, we assume that C<bytep> and C<bytel> are enough for this job.

Return C<NULL> if failure, a grammar object instance on success.

=item marpaESLIFGrammar_eslifp

  marpaESLIF_t           *marpaESLIFGrammar_eslifp(marpaESLIFGrammar_t *marpaESLIFGrammarp);

Return the main ESLIF object instance from a ESLIFGrammar instance, or C<NULL> is failure.

=item marpaESLIFGrammar_ngrammarib

  short                   marpaESLIFGrammar_ngrammarib(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                       int *ngrammarip);

Get the number of grammars in the value pointed by C<ngrammarip> when the later is not C<NULL>. The number of grammars is the highest indice plus one in an internal sparse array of grammars.

Return a true value on failure, a false value on failure.

=item marpaESLIFGrammar_startib

  short                   marpaESLIFGrammar_startib(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                    int *startip);

Return the indice of the start rule of the top grammar in the value pointed by C<startip>, which can be NULL. The top grammar is the first of the grammars (also called grammar at level 0).

Return a true value on failure, a false value on failure.

=item marpaESLIFGrammar_startib

  short                   marpaESLIFGrammar_starti_by_grammarb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                               int *startip,
                                                               int grammari,
                                                               marpaESLIFString_t *descp);

Return the indice of the start rule of the wanted grammar in the value pointed by C<startip>, which can be NULL. The wanted grammar is identifier by:

=over

=item C<grammari>

Indice in the list of grammars, ignored if < 0.

=item C<descp>

Grammar description, always have precedence if it is not C<NULL>. Only C<<descp->bytep>> and C<<descp->bytel>> are considered when looking up grammars using a grammar description.

=back

Return a true value on failure, a false value on failure.

=back

=head1 NOTES

Any of the object of this API is thread-safe but is not I<reentrant>. That is, if user need to access the same object from different threads, he is responsible of doing sychronization.

=head1 SEE ALSO

L<genericLogger|https://github.com/jddurand/c-genericLogger>
