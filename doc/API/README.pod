=encoding UTF-8

=head1 NAME

marpaESLIF_API - Extended Marpa's Scanless Interface API

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

The whole API is available with this include:

  #include <marpaESLIF.h>

There are four namespaces:

=over

=item ESLIF

The main object.

=item ESLIFGrammar

Grammar creation and inspection.

=item ESLIFRecognizer

Parsing phase.

=item ESLIFValue

Valuation phase.

=back

and on transversal type:

  typedef struct marpaESLIFString {
    char   *bytep;            /* pointer bytes */
    size_t  bytel;            /* number of bytes */
    char   *encodingasciis;   /* Encoding of bytes, itself being writen in ASCII encoding, NUL byte terminated */
    char   *asciis;           /* ASCII (un-translatable bytes are changed to a replacement character) translation of previous bytes, NUL byte terminated - never NULL if bytep is not NULL */
    /*
     * Remark: the encodings and asciis pointers are not NULL only when ESLIF know that the buffer is associated to a "description". I.e.
     * this is happening ONLY when parsing the grammar. Raw data never have non-NULL asciis or encodings.
     */
  } marpaESLIFString_t;

which describe what is a I<string>: this is a sequence of C<bytel> bytes, starting at C<bytep> in memory, in eventual C<encodingasciis> encoding, and transliterated into C<asciis>.

=head2 ESLIF

=head3 marpaESLIF_newp

  typedef struct marpaESLIFOption {
    genericLogger_t *genericLoggerp;  /* Logger. Default: NULL */
  } marpaESLIFOption_t;

  marpaESLIF_t           *marpaESLIF_newp(marpaESLIFOption_t *marpaESLIFOptionp);

Any application must start by instanciating a main ESLIF. This method is returning such a main C<marpaESLIF> object, or C<NULL> is failure, using C<marpaESLIFOptionp> that is an eventual pointer to a C<marpaESLIFOption_t> structure. This structure contain:

=over

=item genericLoggerp

A pointer to a C<genericLogger_t> instance. If it is NULL, then C<marpaESLIF> instance, neither any of the other namespaces, will do logging. Otherwise, all will inherit this logger object and use it.

=back

=head3 marpaESLIF_freev

  void                    marpaESLIF_freev(marpaESLIF_t *marpaESLIFp);

The C<marpaESLIF> destructor, with parameter C<marpaESLIFp> being an instance previously created.

=head2 ESLIFGrammar

=head3 marpaESLIFGrammar_newp

  typedef struct marpaESLIFGrammarOption {
    void   *bytep;               /* Input */
    size_t  bytel;               /* Input length in byte unit */
    char   *encodings;           /* Input encoding. Default: NULL */
    size_t  encodingl;           /* Length of encoding itself. Default: 0 */
    char   *encodingOfEncodings; /* Encoding of encoding, in ASCII encoding. Default: NULL. */
  } marpaESLIFGrammarOption_t;

  marpaESLIFGrammar_t    *marpaESLIFGrammar_newp(marpaESLIF_t              *marpaESLIFp,
                                                 marpaESLIFGrammarOption_t *marpaESLIFGrammarOptionp);

This is creating a grammar object instance, with parameters:

=over

=item C<marpaESLIFp>

Object instance of the main ESLIF.

=item C<marpaESLIFGrammarOptionp>

Required pointer to a C<marpaESLIFGrammarOption_t> structure, that contain:

=over

=item C<bytep>

A pointer to the start of the grammar. Must be non-NULL.

=item C<bytel>

Number of bytes. Must be > 0.

=item C<encodings>

Pointer to a buffer containing encoding information of the grammar. Can be NULL.

=item C<encodingl>

Number of bytes of the buffer containing encoding information. Can be 0.

=item C<encodingOfEncodings>

ASCII and NUL-terminated string giving the encoding of the encoding information itself. Can be NULL.

=back

=back

In real life-programming, grammars are assumed to always fit within a single block of memory. So there is no reader of grammar definition, we assume that C<bytep> and C<bytel> are enough for this job.

Return C<NULL> if failure, a grammar object instance on success.

=head3 marpaESLIFGrammar_eslifp

  marpaESLIF_t           *marpaESLIFGrammar_eslifp(marpaESLIFGrammar_t *marpaESLIFGrammarp);

Return the main ESLIF object instance from a ESLIFGrammar instance, or C<NULL> is failure.

=head3 marpaESLIFGrammar_ngrammarib

  short                   marpaESLIFGrammar_ngrammarib(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                       int                 *ngrammarip);

Get the number of grammars in the value pointed by C<ngrammarip> when the later is not C<NULL>. The number of grammars is the highest indice plus one in an internal sparse array of grammars.

Return a true value on failure, a false value on failure.

=head3 marpaESLIFGrammar_grammar_currentb

  short                   marpaESLIFGrammar_grammar_currentb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                             int                 *levelip,
                                                             marpaESLIFString_t **descpp);

Get in the values pointed by C<levelip> and C<descpp>, which can be both C<NULL>, the level and description of I<current> grammar: the default current grammar is the one at level C<0>, nevertheless it is possible to instanciate a parsing at a different level, and if, as a use case, you are sharing the same actions between different levels, this is the way to know which is the current.

Return a true value on failure, a false value on failure.

=head3 marpaESLIFGrammar_grammar_by_levelb

  short                   marpaESLIFGrammar_grammar_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                              int                  leveli,
                                                              marpaESLIFString_t  *descp,
                                                              int                 *levelip,
                                                              marpaESLIFString_t **descpp);

Get in the values pointed by C<levelip> and C<descpp>, which can be both C<NULL>, the level and description of wanted grammar:

=over

=item leveli

is the eventual explicit wanted level, ignored if < C<0>.

=item descp

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 marpaESLIFGrammar_grammar_currentb

  short                   marpaESLIFGrammar_rulearray_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                               int                 **ruleipp,
                                                               size_t               *rulelp);

Get in the values pointed by C<ruleipp> and C<rulelp> the rule indices and the number of such indices of current grammar.

Return a true value on failure, a false value on failure.

=head1 NOTES

Any of the object of this API is thread-safe but is not I<reentrant>. That is, if user need to access the same object from different threads, he is responsible of doing sychronization.

=head1 SEE ALSO

L<genericLogger|https://github.com/jddurand/c-genericLogger>
