=encoding UTF-8

=head1 NAME

marpaESLIF_CALCULATOR - Extended Marpa's Scanless Interface Calculator

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

This documentation is giving a tutorial with a calculator as example.

=head2 GRAMMAR v1

We start with the simplest grammar:

    Expression ::=
        /[\d]+/
        | '(' Expression ')'              assoc => group
       ||     Expression '**' Expression  assoc => right
       ||     Expression  '*' Expression
        |     Expression  '/' Expression
       ||     Expression  '+' Expression
        |     Expression  '-' Expression

which means obviously that an expression is number, or a group of expressions, or an sub-expression where the 'power of' operator has right associativity (i.e. the C<Expression> on the right is to be processed first).

To get that compiled you will need of course marpaESLIF header files, and we use the generic logger to have something in the output. The grammar length is given with C<strlen(), requiring C#<string.h>#, we will use C<perror()> and C<exit()> that requires C#<stdio.h># and C#<stdlib.h>#:

  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <marpaESLIF.h>
  #include <genericLogger.h>

Grammar is set in a constant:

  const static char *grammars =
    "Expression ::=\n"
    "    /[\\d]+/\n"
    "    | '(' Expression ')'              assoc => group\n"
    "   ||     Expression '**' Expression  assoc => right\n"
    "   ||     Expression  '*' Expression\n"
    "    |     Expression  '/' Expression\n"
    "   ||     Expression  '+' Expression\n"
    "    |     Expression  '-' Expression\n"
    "\n";

and main program will instanciate a generic logger:

  genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_DEBUG);

then a marpaESLIF instance:

  marpaESLIFp = marpaESLIF_newp(&marpaESLIFOption);

then compile the grammar:

  marpaESLIFGrammar_t *marpaESLIFGrammarp = marpaESLIFGrammar_newp(marpaESLIFp, &marpaESLIFGrammarOption);

and dump it:

  if (marpaESLIFGrammar_grammarshowform_currentb(marpaESLIFGrammarp, &grammarshows)) {
    GENERICLOGGER_INFOF(genericLoggerp, "Grammar show:\n%s", grammarshows);
  }

=head3 Creating the generic logger

This is as simple as:

  genericLogger_t             *genericLoggerp;
  ./..
  genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_DEBUG);
  if (genericLoggerp == NULL) {
    perror("GENERICLOGGER_NEW");
    exit(1);
  }

=head3 Creating a marpaESLIF instance

A C<marpaESLIFOption_t> structure is filled with generic logger:

  marpaESLIFOption_t           marpaESLIFOption;
  marpaESLIF_t                *marpaESLIFp;
  ./..
  marpaESLIFOption.genericLoggerp = genericLoggerp;

and obviously we does not expect that to fail:

  marpaESLIFp = marpaESLIF_newp(&marpaESLIFOption);
  if (marpaESLIFp == NULL) {
    exit(1);
  }

=head3 Creating a marpaESLIFGrammar instance

A C<marpaESLIFGrammarOption_t> structure is setup like this:

  marpaESLIFGrammarOption_t    marpaESLIFGrammarOption;
  marpaESLIFGrammar_t         *marpaESLIFGrammarp;
  ./..

  marpaESLIFGrammarOption.bytep               = (void *) grammars;
  marpaESLIFGrammarOption.bytel               = strlen(grammars);
  marpaESLIFGrammarOption.encodings           = NULL;
  marpaESLIFGrammarOption.encodingl           = 0;
  marpaESLIFGrammarOption.encodingOfEncodings = NULL;
  marpaESLIFGrammarp = marpaESLIFGrammar_newp(marpaESLIFp, &marpaESLIFGrammarOption);
  if (marpaESLIFGrammarp == NULL) {
    exit(1);
  }

which means: the whole grammar start at C<bytep>, is of length C<bytel>, and I do not know anything about the encoding, please manage it yourself.

=head2 Printing the grammar

By default the current grammar of a a C<marpaESLIFGrammarp> object instance is always the first available grammar, in our case there is a single level (we used C<::=> everywhere), so this is ok to do:

  if (marpaESLIFGrammar_grammarshowform_currentb(marpaESLIFGrammarp, &grammarshows)) {
    GENERICLOGGER_INFOF(genericLoggerp, "Grammar show:\n%s", grammarshows);
  }

=head3 Cleanup

We have to clean the grammar,the marpaESLIF and the generic logger:

  marpaESLIFGrammar_freev(marpaESLIFGrammarp);
  marpaESLIF_freev(marpaESLIFp);
  GENERICLOGGER_FREE(genericLoggerp);


=head3 The program

All in all, this give:

  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <marpaESLIF.h>
  #include <genericLogger.h>
  
  const static char *grammars =
    "Expression ::=\n"
    "    /[\\d]+/\n"
    "    | '(' Expression ')'              assoc => group\n"
    "   ||     Expression '**' Expression  assoc => right\n"
    "   ||     Expression  '*' Expression\n"
    "    |     Expression  '/' Expression\n"
    "   ||     Expression  '+' Expression\n"
    "    |     Expression  '-' Expression\n"
    "\n";
  
  int main() {
    genericLogger_t             *genericLoggerp;
    marpaESLIFOption_t           marpaESLIFOption;
    marpaESLIF_t                *marpaESLIFp;
    marpaESLIFGrammarOption_t    marpaESLIFGrammarOption;
    marpaESLIFGrammar_t         *marpaESLIFGrammarp;
    char                        *grammarshows;
    int                          exiti;
  
    genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_DEBUG);
    if (genericLoggerp == NULL) {
      perror("GENERICLOGGER_NEW");
      exit(1);
    }
  
    marpaESLIFOption.genericLoggerp = genericLoggerp;
    marpaESLIFp = marpaESLIF_newp(&marpaESLIFOption);
    if (marpaESLIFp == NULL) {
      exit(1);
    }
  
    marpaESLIFGrammarOption.bytep               = (void *) grammars;
    marpaESLIFGrammarOption.bytel               = strlen(grammars);
    marpaESLIFGrammarOption.encodings           = NULL;
    marpaESLIFGrammarOption.encodingl           = 0;
    marpaESLIFGrammarOption.encodingOfEncodings = NULL;
    marpaESLIFGrammarp = marpaESLIFGrammar_newp(marpaESLIFp, &marpaESLIFGrammarOption);
    if (marpaESLIFGrammarp == NULL) {
      exit(1);
    }
  
    if (marpaESLIFGrammar_grammarshowform_currentb(marpaESLIFGrammarp, &grammarshows)) {
      GENERICLOGGER_INFOF(genericLoggerp, "Grammar show:\n%s", grammarshows);
      exit(1);
    }
  
    marpaESLIFGrammar_freev(marpaESLIFGrammarp);
    marpaESLIF_freev(marpaESLIFp);
    GENERICLOGGER_FREE(genericLoggerp);

    exit(0);
  }

=head4 Output

The output is interesting, it shows a lot of internals. This was done a machine where PCRE2 is installed with JIT support:

  /*
   * **********************
   * Meta-grammar settings:
   * **********************
   */
  :start ::= Expression
  :default ::= action => ::concat symbol-action => ::shift latm => 1
  
  /*
   * ***************
   * Event settings:
   * ***************
   */
  
  /*
   * ******
   * Rules:
   * ******
   */
  <Expression> ::= <Expression[0]>
  <Expression[0]> ::= <Expression[1]>
  <Expression[1]> ::= <Expression[2]>
  <Expression[2]> ::= <Expression[3]>
  <Expression[3]> ::= /[\d]+/
  <Expression[3]> ::= '(' <Expression[0]> ')'
  <Expression[2]> ::= <Expression[3]> '**' <Expression[2]>
  <Expression[1]> ::= <Expression[1]> '*' <Expression[2]>
  <Expression[1]> ::= <Expression[1]> '/' <Expression[2]>
  <Expression[0]> ::= <Expression[0]> '+' <Expression[1]>
  <Expression[0]> ::= <Expression[0]> '-' <Expression[1]>
  
  #
  # The following is giving information on grammar components: lexemes, rules and symbols properties
  #
  # --------
  # Lexemes:
  # --------
  #
  #
  # -----------------
  # Rules properties:
  # -----------------
  #
  # Rule No 0
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression> ::= <Expression[0]>
  #   Components:  LHS = RHS[]
  #                  0 = 1
  # Rule No 1
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[0]> ::= <Expression[1]>
  #   Components:  LHS = RHS[]
  #                  1 = 2
  # Rule No 2
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[1]> ::= <Expression[2]>
  #   Components:  LHS = RHS[]
  #                  2 = 3
  # Rule No 3
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[2]> ::= <Expression[3]>
  #   Components:  LHS = RHS[]
  #                  3 = 4
  # Rule No 4
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[3]> ::= /[\d]+/
  #   Components:  LHS = RHS[]
  #                  4 = 5
  # Rule No 5
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[3]> ::= '(' <Expression[0]> ')'
  #   Components:  LHS = RHS[]
  #                  4 = 6 1 7
  # Rule No 6
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[2]> ::= <Expression[3]> '**' <Expression[2]>
  #   Components:  LHS = RHS[]
  #                  3 = 4 8 3
  # Rule No 7
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[1]> ::= <Expression[1]> '*' <Expression[2]>
  #   Components:  LHS = RHS[]
  #                  2 = 2 9 3
  # Rule No 8
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[1]> ::= <Expression[1]> '/' <Expression[2]>
  #   Components:  LHS = RHS[]
  #                  2 = 2 10 3
  # Rule No 9
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[0]> ::= <Expression[0]> '+' <Expression[1]>
  #   Components:  LHS = RHS[]
  #                  1 = 1 11 2
  # Rule No 10
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <Expression[0]> ::= <Expression[0]> '-' <Expression[1]>
  #   Components:  LHS = RHS[]
  #                  1 = 1 12 2
  #
  # -------------------
  # Symbols properties:
  # -------------------
  #
  # Symbol No 0
  #         Type: ESLIF META
  #   Properties: ACCESSIBLE, PRODUCTIVE, START
  #         Name: <Expression>
  #
  # Symbol No 1
  #         Type: ESLIF META
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #         Name: <Expression[0]>
  #
  # Symbol No 2
  #         Type: ESLIF META
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #         Name: <Expression[1]>
  #
  # Symbol No 3
  #         Type: ESLIF META
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #         Name: <Expression[2]>
  #
  # Symbol No 4
  #         Type: ESLIF META
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #         Name: <Expression[3]>
  #
  # Symbol No 5
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern:
  #     0x000000: 5b 5c 64 5d 2b                                  [\d]+           
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # Symbol No 6
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: \(
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # Symbol No 7
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: \)
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # Symbol No 8
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: \*\*
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # Symbol No 9
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: \*
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # Symbol No 10
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: /
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # Symbol No 11
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: \+
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # Symbol No 12
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: -
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes

We see that:

=over

=item * The start rule has been automatically set to the first rule, i.e. C<Expression>

=item * The default settings of a grammar are using pre-defined built-in actions:

=over

=item * Concatenation of all symbols at the rule level

=item * Lexeme itself at the symbol level

(it could have been C<::concat>, which is equivalent to C<::shift> where there is a single RHS)

=back

=item * Longest Acceptable Token Match is on by default

=item * The I<loosen> operator C<||> has been dissected into suite of normal alternatives

=item * There is no reference to a meta symbol of another grammar

=item * There are 10 rules

=item * There are 12 symbols

=back

=head1 NOTES

This example is a copy/paste from L<Marpa::R2's Semantics|https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics.pod> documentation.

=head1 SEE ALSO

L<marpaESLIF|https://github.com/jddurand/c-marpaESLIF>
