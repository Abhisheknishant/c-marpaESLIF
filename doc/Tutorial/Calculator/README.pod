=encoding UTF-8

=head1 NAME

marpaESLIF_CALCULATOR - Extended Marpa's Scanless Interface Calculator

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

This documentation is giving a tutorial with a calculator as example.

=head2 GRAMMAR v1

We start with the simplest grammar:

    Expression ::=
        /[\d]+/
        | '(' Expression ')'              assoc => group
       ||     Expression '**' Expression  assoc => right
       ||     Expression  '*' Expression
        |     Expression  '/' Expression
       ||     Expression  '+' Expression
        |     Expression  '-' Expression

which means obviously that an expression is number, or a group of expressions, or an sub-expression where the 'power of' operator has right associativity (i.e. the C<Expression> on the right is to be processed first).

To get that compiled you will need of course marpaESLIF header files, and we use the generic logger to have something in the output. The grammar length is given with C<strlen(), requiring C#<string.h>#, we will use C<perror()> and C<exit()> that requires C#<stdio.h># and C#<stdlib.h>#:

  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <marpaESLIF.h>
  #include <genericLogger.h>

Grammar is set in a constant:

  const static char *grammars =
    "Expression ::=\n"
    "    /[\\d]+/\n"
    "    | '(' Expression ')'              assoc => group\n"
    "   ||     Expression '**' Expression  assoc => right\n"
    "   ||     Expression  '*' Expression\n"
    "    |     Expression  '/' Expression\n"
    "   ||     Expression  '+' Expression\n"
    "    |     Expression  '-' Expression\n"
    "\n";

and main program will instanciate a generic logger:

  genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_DEBUG);

then a marpaESLIF instance:

  marpaESLIFp = marpaESLIF_newp(&marpaESLIFOption);

then compile the grammar:

  marpaESLIFGrammar_t *marpaESLIFGrammarp = marpaESLIFGrammar_newp(marpaESLIFp, &marpaESLIFGrammarOption);

=head3 Creating the generic logger

This is as simple as:

  genericLogger_t             *genericLoggerp;
  ./..
  genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_DEBUG);
  if (genericLoggerp == NULL) {
    perror("GENERICLOGGER_NEW");
    exit(1);
  }

=head3 Creating a marpaESLIF instance

A C<marpaESLIFOption_t> structure is filled with generic logger:

  marpaESLIFOption_t           marpaESLIFOption;
  marpaESLIF_t                *marpaESLIFp;
  ./..
  marpaESLIFOption.genericLoggerp = genericLoggerp;

and obviously we does not expect that to fail:

  marpaESLIFp = marpaESLIF_newp(&marpaESLIFOption);
  if (marpaESLIFp == NULL) {
    exit(1);
  }

=head3 Creating a marpaESLIFGrammar instance

A C<marpaESLIFGrammarOption_t> structure is setup like this:

  marpaESLIFGrammarOption_t    marpaESLIFGrammarOption;
  marpaESLIFGrammar_t         *marpaESLIFGrammarp;
  ./..

  marpaESLIFGrammarOption.bytep               = (void *) grammars;
  marpaESLIFGrammarOption.bytel               = strlen(grammars);
  marpaESLIFGrammarOption.encodings           = NULL;
  marpaESLIFGrammarOption.encodingl           = 0;
  marpaESLIFGrammarOption.encodingOfEncodings = NULL;
  marpaESLIFGrammarp = marpaESLIFGrammar_newp(marpaESLIFp, &marpaESLIFGrammarOption);
  if (marpaESLIFGrammarp == NULL) {
    exit(1);
  }

which means: the whole grammar start at C<bytep>, is of length C<bytel>, and I do not know anything about the encoding, please manage it yourself.

=head3 Cleanup

We have to clean the grammar,the marpaESLIF and the generic logger:

  marpaESLIFGrammar_freev(marpaESLIFGrammarp);
  marpaESLIF_freev(marpaESLIFp);
  GENERICLOGGER_FREE(genericLoggerp);


=head3 The program

All in all, this give:

  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <marpaESLIF.h>
  #include <genericLogger.h>
  
  const static char *grammars =
    "Expression ::=\n"
    "    /[\\d]+/\n"
    "    | '(' Expression ')'              assoc => group\n"
    "   ||     Expression '**' Expression  assoc => right\n"
    "   ||     Expression  '*' Expression\n"
    "    |     Expression  '/' Expression\n"
    "   ||     Expression  '+' Expression\n"
    "    |     Expression  '-' Expression\n"
    "\n";
  
  int main() {
    genericLogger_t             *genericLoggerp;
    marpaESLIFOption_t           marpaESLIFOption;
    marpaESLIF_t                *marpaESLIFp;
    marpaESLIFGrammarOption_t    marpaESLIFGrammarOption;
    marpaESLIFGrammar_t         *marpaESLIFGrammarp;
    int                          exiti;
  
    genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_DEBUG);
    if (genericLoggerp == NULL) {
      perror("GENERICLOGGER_NEW");
      exit(1);
    }
  
    marpaESLIFOption.genericLoggerp = genericLoggerp;
    marpaESLIFp = marpaESLIF_newp(&marpaESLIFOption);
    if (marpaESLIFp == NULL) {
      exit(1);
    }
  
    marpaESLIFGrammarOption.bytep               = (void *) grammars;
    marpaESLIFGrammarOption.bytel               = strlen(grammars);
    marpaESLIFGrammarOption.encodings           = NULL;
    marpaESLIFGrammarOption.encodingl           = 0;
    marpaESLIFGrammarOption.encodingOfEncodings = NULL;
    marpaESLIFGrammarp = marpaESLIFGrammar_newp(marpaESLIFp, &marpaESLIFGrammarOption);
    if (marpaESLIFGrammarp == NULL) {
      exit(1);
    }
  
    marpaESLIFGrammar_freev(marpaESLIFGrammarp);
    marpaESLIF_freev(marpaESLIFp);
    GENERICLOGGER_FREE(genericLoggerp);

    exit(0);
  }

=head2 Grammar v2: discard and actions

Obviously, we would like the grammar to discard automatically any non-significant I<whitespace>, as it is done traditionnaly in any language:

  :discard ::= [\s]

will do it.

And we want to have I<actions> to compute the arithmetic result:

=over

=item * C</[\d]+/> obviously give an integer

        /[\d]+/ action => do_int

=item * Any other rule can give anything, we will choose a C<double> for convenience

No need to duplicate an eventual C<action => do_double> everywhere, since these are the only other rules, we can put that in the C<:default> statement:

  :default ::= action => do_double

So we end up with this grammar:

    :default ::= action => do_double
    :discard ::= [\s]
    Expression ::=
        /[\d]+/                           action => do_int
        | '(' Expression ')'              assoc => group
       ||     Expression '**' Expression  assoc => right
       ||     Expression  '*' Expression
        |     Expression  '/' Expression
       ||     Expression  '+' Expression
        |     Expression  '-' Expression


At this stage, if we do not instanciate any valuation, it is perfectly okay to have no action implementation. Indeed, we can try immediately to parse some input. For example one that is compliant with the grammar:



=back

=head1 NOTES

This example is a copy/paste from L<Marpa::R2's Semantics|https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics.pod> documentation.

=head1 SEE ALSO

L<marpaESLIF|https://github.com/jddurand/c-marpaESLIF>
