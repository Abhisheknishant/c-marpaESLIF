=encoding UTF-8

=head1 NAME

marpaESLIF_CALCULATOR - Extended Marpa's Scanless Interface Calculator

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

This documentation is giving a tutorial with a calculator as example.

=head2 GRAMMAR v1

We start with the simplest grammar:

    Expression ::=
        /[\d]+/
        | '(' Expression ')'              assoc => group
       ||     Expression '**' Expression  assoc => right
       ||     Expression  '*' Expression
        |     Expression  '/' Expression
       ||     Expression  '+' Expression
        |     Expression  '-' Expression

which means obviously that an expression is number, or a group of expressions, or an sub-expression where the 'power of' operator has right associativity (i.e. the C<Expression> on the right is to be processed first).

To get that compiled you will need of course marpaESLIF header files, and we use the generic logger to have something in the output. The grammar length is given with C<strlen(), requiring C#<string.h>#, we will use C<perror()> and C<exit()> that requires C#<stdio.h># and C#<stdlib.h>#:

  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <marpaESLIF.h>
  #include <genericLogger.h>

Grammar is set in a constant:

  const static char *grammars =
    "Expression ::=\n"
    "    /[\\d]+/\n"
    "    | '(' Expression ')'              assoc => group\n"
    "   ||     Expression '**' Expression  assoc => right\n"
    "   ||     Expression  '*' Expression\n"
    "    |     Expression  '/' Expression\n"
    "   ||     Expression  '+' Expression\n"
    "    |     Expression  '-' Expression\n"
    "\n";

and main program will instanciate a generic logger:

  genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_DEBUG);

then a marpaESLIF instance:

  marpaESLIFp = marpaESLIF_newp(&marpaESLIFOption);

then compile the grammar:

  marpaESLIFGrammar_t *marpaESLIFGrammarp = marpaESLIFGrammar_newp(marpaESLIFp, &marpaESLIFGrammarOption);

=head3 Creating the generic logger

This is as simple as:

  genericLogger_t             *genericLoggerp;
  ./..
  genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_DEBUG);
  if (genericLoggerp == NULL) {
    perror("GENERICLOGGER_NEW");
    exit(1);
  }

=head3 Creating a marpaESLIF instance

A C<marpaESLIFOption_t> structure is filled with generic logger:

  marpaESLIFOption_t           marpaESLIFOption;
  marpaESLIF_t                *marpaESLIFp;
  ./..
  marpaESLIFOption.genericLoggerp = genericLoggerp;

and obviously we does not expect that to fail:

  marpaESLIFp = marpaESLIF_newp(&marpaESLIFOption);
  if (marpaESLIFp == NULL) {
    exit(1);
  }

=head3 Creating a marpaESLIFGrammar instance

A C<marpaESLIFGrammarOption_t> structure is setup like this:

  marpaESLIFGrammarOption_t    marpaESLIFGrammarOption;
  marpaESLIFGrammar_t         *marpaESLIFGrammarp;
  ./..

  marpaESLIFGrammarOption.bytep               = (void *) grammars;
  marpaESLIFGrammarOption.bytel               = strlen(grammars);
  marpaESLIFGrammarOption.encodings           = NULL;
  marpaESLIFGrammarOption.encodingl           = 0;
  marpaESLIFGrammarOption.encodingOfEncodings = NULL;
  marpaESLIFGrammarp = marpaESLIFGrammar_newp(marpaESLIFp, &marpaESLIFGrammarOption);
  if (marpaESLIFGrammarp == NULL) {
    exit(1);
  }

which means: the whole grammar start at C<bytep>, is of length C<bytel>, and I do not know anything about the encoding, please manage it yourself.

=head3 Cleanup

We have to clean the grammar,the marpaESLIF and the generic logger:

  marpaESLIFGrammar_freev(marpaESLIFGrammarp);
  marpaESLIF_freev(marpaESLIFp);
  GENERICLOGGER_FREE(genericLoggerp);


=head3 The program

All in all, this give:

  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <marpaESLIF.h>
  #include <genericLogger.h>
  
  const static char *grammars =
    "Expression ::=\n"
    "    /[\\d]+/\n"
    "    | '(' Expression ')'              assoc => group\n"
    "   ||     Expression '**' Expression  assoc => right\n"
    "   ||     Expression  '*' Expression\n"
    "    |     Expression  '/' Expression\n"
    "   ||     Expression  '+' Expression\n"
    "    |     Expression  '-' Expression\n"
    "\n";
  
  int main() {
    genericLogger_t             *genericLoggerp;
    marpaESLIFOption_t           marpaESLIFOption;
    marpaESLIF_t                *marpaESLIFp;
    marpaESLIFGrammarOption_t    marpaESLIFGrammarOption;
    marpaESLIFGrammar_t         *marpaESLIFGrammarp;
    int                          exiti;
  
    genericLoggerp = GENERICLOGGER_NEW(GENERICLOGGER_LOGLEVEL_DEBUG);
    if (genericLoggerp == NULL) {
      perror("GENERICLOGGER_NEW");
      exit(1);
    }
  
    marpaESLIFOption.genericLoggerp = genericLoggerp;
    marpaESLIFp = marpaESLIF_newp(&marpaESLIFOption);
    if (marpaESLIFp == NULL) {
      exit(1);
    }
  
    marpaESLIFGrammarOption.bytep               = (void *) grammars;
    marpaESLIFGrammarOption.bytel               = strlen(grammars);
    marpaESLIFGrammarOption.encodings           = NULL;
    marpaESLIFGrammarOption.encodingl           = 0;
    marpaESLIFGrammarOption.encodingOfEncodings = NULL;
    marpaESLIFGrammarp = marpaESLIFGrammar_newp(marpaESLIFp, &marpaESLIFGrammarOption);
    if (marpaESLIFGrammarp == NULL) {
      exit(1);
    }
  
    marpaESLIFGrammar_freev(marpaESLIFGrammarp);
    marpaESLIF_freev(marpaESLIFp);
    GENERICLOGGER_FREE(genericLoggerp);

    exit(0);
  }

=head2 Grammar v2: discard and actions

Obviously, we would like the grammar to discard automatically any non-significant I<whitespace>, as it is done traditionnaly in any language:

  :discard ::= [\s]

will do it.

And we want to have I<actions> to compute the arithmetic result:

=over

=item * C</[\d]+/> obviously give an integer

        /[\d]+/ action => do_int

=item * Any other rule can give anything, we will choose a C<double> for convenience

No need to duplicate an eventual C<action => do_double> everywhere, since these are the only other rules, we can put that in the C<:default> statement:

  :default ::= action => do_double

So we end up with this grammar:

    :default ::= action => do_double
    :discard ::= [\s]
    Expression ::=
        /[\d]+/                           action => do_int
        | '(' Expression ')'              assoc => group
       ||     Expression '**' Expression  assoc => right
       ||     Expression  '*' Expression
        |     Expression  '/' Expression
       ||     Expression  '+' Expression
        |     Expression  '-' Expression


At this stage, if we do not instanciate any valuation, it is perfectly okay to have no action implementation. Indeed, we can try immediately to parse some input. For example one that is compliant with the grammar. Since marpaESLIF is working natively in stream mode, we have to have a I<reader>, that in our case will send the whole chunk of input in one go:

  typedef struct reader_context {
    char            *inputs;
    size_t           inputl;
  } reader_context_t;

  static short inputReaderb(void    *userDatavp,
                            char   **inputsp,
                            size_t  *inputlp,
                            short   *eofbp,
                            short   *characterStreambp,
                            char   **encodingOfEncodingsp,
                            char   **encodingsp,
                            size_t  *encodinglp);
  ./..
  
  static short inputReaderb(void    *userDatavp,
                            char   **inputsp,
                            size_t  *inputlp,
                            short   *eofbp,
                            short   *characterStreambp,
                            char   **encodingOfEncodingsp,
                            char   **encodingsp,
                            size_t  *encodinglp)
  {
    reader_context_t *reader_contextp = (reader_context_t *) userDatavp;
  
    *inputsp              = reader_contextp->inputs;
    *inputlp              = reader_contextp->inputl;
    *eofbp                = 1;    /* One chunk */
    *characterStreambp    = 1;    /* We say this is a stream of characters */
    *encodingOfEncodingsp = NULL; /* let marpaESLIF deal with encoding */
    *encodingsp           = NULL;
    *encodinglp           = 0;

    return 1;
  }

We cannot use the C<marpaESLIFGrammar_parseb> method yet, because it will try to perform valuation. But we can ask for scanning, and only that with the method C<marpaESLIFRecognizer_scanb>. So we will instanciate a recognizer:

  reader_context_t             reader_context;
  marpaESLIFRecognizerOption_t marpaESLIFRecognizerOption;
  marpaESLIFRecognizer_t      *marpaESLIFRecognizerp;
  ./..
  marpaESLIFRecognizerOption.userDatavp                = &reader_context;
  marpaESLIFRecognizerOption.marpaESLIFReaderCallbackp = inputReaderb;
  marpaESLIFRecognizerOption.disableThresholdb         = 0;  /* No disable of threshold warning */
  marpaESLIFRecognizerOption.exhaustedb                = 0;  /* No exhaustion event */
  marpaESLIFRecognizerOption.newlineb                  = 1;  /* Do newline counting */
  marpaESLIFRecognizerOption.bufsizl                   = 0;  /* Recommended value */
  marpaESLIFRecognizerOption.buftriggerperci           = 50; /* Recommended value */
  marpaESLIFRecognizerOption.bufaddperci               = 50; /* Recommended value */
  marpaESLIFRecognizerp = marpaESLIFRecognizer_newp(marpaESLIFGrammarp, &marpaESLIFRecognizerOption);
  if (marpaESLIFRecognizerp == NULL) {
    exit(1);
  }
  ./..
  marpaESLIFRecognizer_freev(marpaESLIFRecognizerp);

And ask for a scan of what it is in C<stdin> (we assume that 4096 bytes is enough -;):

  char                         inputs[4096];
  ./..
  if (fgets(inputs, sizeof(inputs), stdin) == NULL) {
    perror("fgets");
    exit(1);
  }
  reader_context.inputs = inputs;
  reader_context.inputl = strlen(inputs);
  if (! marpaESLIFRecognizer_scanb(marpaESLIFRecognizerp,
                                   0 /* initialEventsb */,
                                   NULL /* continuebp*/,
                                   NULL /* exhaustedbp */)) {
    exit(1);
  }

Let's try on something that will be ok:

  echo 1 | /path/to/your/calculator

... And with spaces:

  echo "1 + 2" | /path/to/your/calculator

No output. Good, parsing was ok. Now on something that is not ok:

  echo "( 1 + 2 xxxxx" | /tmp/Calculator

Output looks like (we removed a timestamp generated by the generic logger -;):

  ERROR --------------------------------------------
  ERROR Recognizer failure. Current state:
  ERROR [F3@3..4] Expression[1] ::= Expression[2] .
  ERROR [F4@3..4] Expression[2] ::= Expression[3] .
  ERROR [F5@3..4] Expression[3] ::= /[\d]+/ .
  ERROR [F10@1..4] Expression[0] ::= Expression[0]
  ERROR [F10@1..4]                   '+'
  ERROR [F10@1..4]                   Expression[1] .
  ERROR [R7@3..4] Expression[2] ::= Expression[3]
  ERROR [R7@3..4]                   . '**'
  ERROR [R7@3..4]                   Expression[2]
  ERROR [R8@3..4] Expression[1] ::= Expression[1]
  ERROR [R8@3..4]                   . '*'
  ERROR [R8@3..4]                   Expression[2]
  ERROR [R9@3..4] Expression[1] ::= Expression[1]
  ERROR [R9@3..4]                   . '/'
  ERROR [R9@3..4]                   Expression[2]
  ERROR [R10@1..4] Expression[0] ::= Expression[0]
  ERROR [R10@1..4]                   . '+'
  ERROR [R10@1..4]                   Expression[1]
  ERROR [R11@1..4] Expression[0] ::= Expression[0]
  ERROR [R11@1..4]                   . '-'
  ERROR [R11@1..4]                   Expression[1]
  ERROR [R6@0..4] Expression[3] ::= '('
  ERROR [R6@0..4]                   Expression[0]
  ERROR [R6@0..4]                   . ')'
  ERROR --------------------------------------------
  ERROR Expected terminal: ')'
  ERROR Expected terminal: '**'
  ERROR Expected terminal: '*'
  ERROR Expected terminal: '/'
  ERROR Expected terminal: '+'
  ERROR Expected terminal: '-'
  ERROR --------------------------------------------
  ERROR UTF-8 converted data before the failure (8 bytes)
  ERROR 0x000000: 28 20 31 20 2b 20 32 20                         ( 1 + 2         
  ERROR --------------------------------------------
  ERROR <<<<<< RECOGNIZER FAILURE AFTER LINE No 1 COLUMN No 8, HERE: >>>>>>
  ERROR --------------------------------------------
  ERROR UTF-8 converted data after the failure (6 bytes)
  ERROR 0x000000: 78 78 78 78 78 0a                               xxxxx.          
  ERROR --------------------------------------------

You see that by default, marpaESLIF will always send to the generic logger, at the C<ERROR> log level, all valuable information:

=over

=item * A progress report of current grammar position in the scanning

=item * The expected terminals and their definition

Their definition, here, is always an ASCII representation tentative.

=item * A dump of the input

The dump always takes into account if this is stream of characters or not, by saying so: C<UTF-8 converted data>. In case of a binary stream it would say C<Raw data>. The dump is always giving a maximum of C<128> bytes before and after the exact point of failure in input, when possible.

=back

So take care, this is just a I<test of the parsing phase>. Parsing can be complete, this does not mean that there is a value. For example, just scanning this:

  echo "( 1 + 2" | /tmp/Calculator

will output nothing. And this is normal. From the grammar point of view, even if parsing is not complete, parsing did not fail: the input was conform to the grammar up to its end. This is by doing valuation that we will discover there is a problem... This can also be predicted by asking for the state of the recognizer... Suppose there would be this line of code just after scanning:

  marpaESLIFRecognizer_progressLogb(marpaESLIFRecognizerp, -1, -1, GENERICLOGGER_LOGLEVEL_DEBUG);

then the output would be:

  DEBUG [F3@3..4] Expression[1] ::= Expression[2] .
  DEBUG [F4@3..4] Expression[2] ::= Expression[3] .
  DEBUG [F5@3..4] Expression[3] ::= /[\d]+/ .
  DEBUG [F10@1..4] Expression[0] ::= Expression[0]
  DEBUG [F10@1..4]                   '+'
  DEBUG [F10@1..4]                   Expression[1] .
  DEBUG [R7@3..4] Expression[2] ::= Expression[3]
  DEBUG [R7@3..4]                   . '**'
  DEBUG [R7@3..4]                   Expression[2]
  DEBUG [R8@3..4] Expression[1] ::= Expression[1]
  DEBUG [R8@3..4]                   . '*'
  DEBUG [R8@3..4]                   Expression[2]
  DEBUG [R9@3..4] Expression[1] ::= Expression[1]
  DEBUG [R9@3..4]                   . '/'
  DEBUG [R9@3..4]                   Expression[2]
  DEBUG [R10@1..4] Expression[0] ::= Expression[0]
  DEBUG [R10@1..4]                   . '+'
  DEBUG [R10@1..4]                   Expression[1]
  DEBUG [R11@1..4] Expression[0] ::= Expression[0]
  DEBUG [R11@1..4]                   . '-'
  DEBUG [R11@1..4]                   Expression[1]
  DEBUG [R6@0..4] Expression[3] ::= '('
  DEBUG [R6@0..4]                   Expression[0]
  DEBUG [R6@0..4]                   . ')'

and we see clearly that rule No C<6> is not complete...:

  DEBUG [R6@0..4] Expression[3] ::= '('
  DEBUG [R6@0..4]                   Expression[0]
  DEBUG [R6@0..4]                   . ')'

=back

=head1 NOTES

This example is a copy/paste from L<Marpa::R2's Semantics|https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics.pod> documentation.

=head1 SEE ALSO

L<marpaESLIF|https://github.com/jddurand/c-marpaESLIF>
