=for html <a href="https://travis-ci.org/jddurand/c-marpaESLIF"><img src="https://travis-ci.org/jddurand/c-marpaESLIF.svg?branch=master" alt="Travis CI build status" height="18"></a> <a href="https://badge.fury.io/gh/jddurand%2Fc-marpaESLIF"><img src="https://badge.fury.io/gh/jddurand%2Fc-marpaESLIF.svg" alt="GitHub version" height="18"></a> <a href="http://opensource.org/licenses/MIT" rel="nofollow noreferrer"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License MIT" height="18"></a>

=head1 NAME

marpaESLIF - Extended Marpa's Scanless Interface

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

The L<marpaESLIF BNF|https://github.com/jddurand/c-marpaESLIF/tree/master/doc/BNF> is inspired from L<Marpa::R2's DSL|https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/DSL.pod>, though with some incompatible changes and many add-ons, in particular:

=over

=item native regular expression support

=item syntactic exception

=item unlimited number of sub-grammars

=item streaming compatible architecture

=back

=head1 Architecture

The ESLIF is nothing else but a I<sparse array> of grammars, identified by an indice called I<level> and starting with value 0, or a description:

           ---------------------------------------------------------
  Indice: | Level 0 | N/A | Level 2 | Level 3 | N/A | Level 5 | ... |
  Name  : | nameof0 | N/A | nameof2 | nameof3 | N/A | nameof5 | ... |
           ---------------------------------------------------------

There B<must> be a grammar at level indice 0. Then any grammar can access any symbol of any other grammar:

           ---------------------------------------------------------
  Indice: | Level 0 | N/A | Level 2 | Level 3 | N/A | Level 5 | ... |
  Name  : | nameof0 | N/A | nameof2 | nameof3 | N/A | nameof5 | ... |
          |---------------------------------------------------------|
  Symbol: | +>X             +>X       +>Xx                          |
  Symbol: | |  Y            |  Y      |  Yy                         |
  Symbol: | |  |            |  |      |  |             +>Zzz        |
          | |  |            |  |      |  |             |   |        |
          | |  |____________|  |______|  |_____________|   |        |
          | |______________________________________________|        |
           ---------------------------------------------------------

If we note a symbol in the form S[i], meaning I<symbol S of grammar level i>, then the schema above say that Y[0] is a reference to X[2], that Y[2] is a reference to Xx[3], that Yy[3] is a reference to Zzz[5], and that Zzz[5] is a reference to Y[0]. Any symbol of any grammar that is accessed I<via a reference> is considered being part of a lexing phase, and the user will have no control until this phase is over, this symbol being recognized or not.

This is why it is required that grammar at level 0 exist: it is considered by the author a common practice that the I<top level> grammar should be at level 0. Though technically this is not absolutely required -; In fact, it is possible to start parsing by specifying I<another> grammar but the one at level 0 as a starting grammar.

The lifetime of parsing, for a given I<location> in the top-level grammar, consist by assigning a set of symbols (these are called I<alternatives>), commiting them (we say that we I<complete> the set of alternatives), and move on. A Scanless Interface mean that you do not have to write your own analysis of input: grammars give definition of what is expected, and the interface have the possbility to determine all the alternatives for you, commiting them, and move on in the input stream. We say input stream: this is another dimension:

           ---------------------------------------------------  STREAM MANAGEMENT
 Rule:    | X ::= x y                                         |
          |---------------------------------------------------| STEP 0
          | Location is start of rule X[0]:                   |
          | X ::= . x y                                       |
          | Suppose that expected "terminals" are T1 and T2:  |
          |---------------------------------------------------| STEP 1
          | Try to match T1                                   |
          |   Nothing yet in the stream ?                     |<-----> Stream reader callback
          |   T1 may match but we are not sure                |<-----> Stream reader callback
          |   Repeat until T1 matches for sure or not         |
          |---------------------------------------------------| STEP 2
          | Try to match T2                                   |
          |   T2 may match but we are not sure                |<-----> Stream reader callback
          |   Repeat until T2 matches for sure or not         |
          |---------------------------------------------------|
          | No match ? End of scanning                        | STEP 3
          | Match ? Commit alternatives T1 and T2 and continue|
           ---------------------------------------------------

=head1 SEE ALSO

L<marpaESLIF_BNF|https://github.com/jddurand/c-marpaESLIF/tree/master/doc/BNF>
