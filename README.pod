=encoding UTF-8

=for html <a href="https://travis-ci.org/jddurand/c-marpaESLIF"><img src="https://travis-ci.org/jddurand/c-marpaESLIF.svg?branch=master" alt="Travis CI build status" height="18"></a> <a href="https://badge.fury.io/gh/jddurand%2Fc-marpaESLIF"><img src="https://badge.fury.io/gh/jddurand%2Fc-marpaESLIF.svg" alt="GitHub version" height="18"></a> <a href="http://opensource.org/licenses/MIT" rel="nofollow noreferrer"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License MIT" height="18"></a>

=head1 NAME

marpaESLIF - Extended Marpa's Scanless Interface

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

The L<marpaESLIF BNF|https://github.com/jddurand/c-marpaESLIF/tree/master/doc/BNF> is inspired from L<Marpa::R2's DSL|https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/DSL.pod>, though with some incompatible changes and many add-ons, in particular:

=over

=item native regular expression support

=item syntactic exception

=item unlimited number of sub-grammars

=item streaming compatible architecture

=back

=head1 Architecture

=head2 Grammars

The ESLIF is nothing else but a I<sparse array> of grammars, identified by an indice called I<level> and starting with value 0, or a description:

           ---------------------------------------------------------
  Indice: | Level 0 | N/A | Level 2 | Level 3 | N/A | Level 5 | ... |
  Name  : | nameof0 | N/A | nameof2 | nameof3 | N/A | nameof5 | ... |
           ---------------------------------------------------------

There B<must> be a grammar at level indice 0. Then any grammar can access any symbol of any other grammar:

           ---------------------------------------------------------
  Indice: | Level 0 | N/A | Level 2 | Level 3 | N/A | Level 5 | ... |
  Name  : | nameof0 | N/A | nameof2 | nameof3 | N/A | nameof5 | ... |
          |---------------------------------------------------------|
  Symbol: | +>X             +>X       +>Xx                          |
  Symbol: | |  Y            |  Y      |  Yy                         |
  Symbol: | |  |            |  |      |  |             +>Zzz        |
          | |  |            |  |      |  |             |   |        |
          | |  |____________|  |______|  |_____________|   |        |
          | |______________________________________________|        |
           ---------------------------------------------------------

If we note a symbol in the form S[i], meaning I<symbol S of grammar level i>, then the schema above say that Y[0] is a reference to X[2], that Y[2] is a reference to Xx[3], that Yy[3] is a reference to Zzz[5], and that Zzz[5] is a reference to Y[0]. Any symbol of any grammar that is accessed I<via a reference> is considered being part of a lexing phase, and the user will have no control until this phase is over, this symbol being recognized or not.

This is why it is required that grammar at level 0 exist: it is considered by the author a common practice that the I<top level> grammar should be at level 0. Though technically this is not absolutely required -; In fact, it is possible to start parsing by specifying I<another> grammar but the one at level 0 as a starting grammar.

=head2 Recognizer

=head3 Top recognizer

The lifetime of parsing, for a given I<location> in the top-level grammar, consist by assigning a set of symbols (these are called I<alternatives>), commiting them (we say that we I<complete> the set of alternatives), and move on. A Scanless Interface mean that you do not have to write your own analysis of input: grammars give definition of what is expected, and the interface have the possbility to determine all the alternatives for you, commiting them, and move on in the input stream. We say input stream: this is another dimension (we suppose from now on that the top-level grammar is at level 0):

  #
  # Note
  #
  #    ::= is an alias for grammar level 0
  #      ~ is an alias for grammar level 1
  # :[n]:= is the generic form for grammar level n
  #
           ---------------------------------------------------  STREAM MANAGEMENT
          | Rule is X ::= x y                                 |
          |---------------------------------------------------| STEP 0
          | Location is start of rule X[0]:                   |
          | X ::= . x y                                       |
          | Suppose that expected "terminals" are T1 and T2:  |
          |---------------------------------------------------| STEP 1
          | Try to match T1                                   |
          |   Nothing yet in the stream ?                     |<-----> Stream reader callback
          |   T1 may match but we are not sure                |<-----> Stream reader callback
          |   Repeat until T1 matches for sure or not         |
          |---------------------------------------------------| STEP 2
          | Try to match T2                                   |
          |   T2 may match but we are not sure                |<-----> Stream reader callback
          |   Repeat until T2 matches for sure or not         |
          |---------------------------------------------------|
          | No match ? End of scanning                        | STEP 3
          | Match ? Commit T1 and T2 and continue             |
           ---------------------------------------------------

=head3 Sub-recognizers

The stream management mentionned above is transversal to any grammar: As soon as "terminal" is in reality a referenced symbol, a sub-recognizer is instanciated and it is sharing the stream with is parent:


                    TOP RECOGNIZER ON GRAMMAR LEVEL 0

           ---------------------------------------------------            STREAM MANAGEMENT
          | Rule is X ::= x y                                 |
          |---------------------------------------------------| STEP 0.0
          | Location is start of rule X[0]:                   |
          | X ::= . x y                                       |
          | Suppose that expected "terminals" are T1 and T2:  |
          |---------------------------------------------------| STEP 0.1
          | Try to match T1                                   |
          |   Nothing yet in the stream ?                     |<-----> Stream reader callback
          |   T1 may match but we are not sure                |<-----> Stream reader callback
          |   Repeat until T1 matches for sure or not         |
          |---------------------------------------------------| STEP 0.2
          | Try to match T2                                   |
          |   T2 is a referenced symbol in grammar n          |
           ---------------------------------------------------

                    SUB-RECOGNIZER ON GRAMMAR LEVEL n

             -------------------------------------------------
            | Rule is T2 :[n]:= a b                           |
            |-------------------------------------------------| STEP 1.0
            | Location is start of rule T2[n]:                |
            | T2 :[n]:= . a b                                 |
            | Suppose that expected "terminals" are U1 and U2:|
            |-------------------------------------------------| STEP 1.1
            | Try to match U1                                 |
            |   Nothing yet in the stream ?                   |<-----> Stream reader callback
            |   U1 may match but we are not sure              |<-----> Stream reader callback
            |   Repeat until U1 matches for sure or not       |
            |-------------------------------------------------| STEP 1.2
            | Try to match U2                                 |
            |   U2 may match but we are not sure              |<-----> Stream reader callback
            |   Repeat until U2 matches for sure or not       |
            |-------------------------------------------------|
            | No match ? End of scanning for T2[n]            | STEP 1.3
            | Match ? Commit U1 and/or U2 and continue        |
             -------------------------------------------------
            | Do internal valuation                           | STEP 1.4
             -------------------------------------------------

                 BACK TO TOP RECOGNIZER ON GRAMMAR LEVEL 0

           ---------------------------------------------------
          | No match ? End of scanning                        | STEP 0.3
          | Match ? Commit T1 and/or T2 and continue          |
          | If T2 matches it is a parse tree value            |
           ---------------------------------------------------

And this is recursive: there will as many sub-recognizers instanciated as there are sub-grammars involved. For instance if terminal C<U2> above is a referenced symbol at grammar level C<l>, a second sub-recognizer will be instanced by the first sub-recognizer. Every child recognizer is sharing all needed transveral information, that is everything about stream management. The main difference between the top recognizer and any child recognizer is that a child recognizer is always doing an internal valuation to retreive the span in the input stream for, and give that back to its parent.

The internal valuation is a forced mode that is concatenating all matched bytes in the input stream.

=head3 Discard and sub-recognizers

You might say, why explicitely doing an internal valuation: the match is where sub-recognizer started and where it ended. No, because any grammar can have it own I<discard> mechanism. This mean that what a sub-recognizer matched may be shorter than the number of bytes effectively consumed from the input stream. So, we have just introduced the notion of I<discard>:

discard is yet another symbol in any grammar, but with special semantic, and its name in the BNF is always C<:discard>. For example:

  :discard   ::= whitespace
  whitespace   ~ /[\s]+/

mean that grammar at level 0 always try to match the C<whitespace> symbol when it failed to match any of the expected terminals.

As soon as there is no match, and if C<:discard> rule exist, any recognizer is always trying to get a match on it using a sub-recognizer, exactly like when it is executing a sub-recognizer for a terminal referencing a symbol in another grammar. Furthermore nothing distinguishes the special symbol C<:discard> from the others: it can also reference any symbol in any other sub-grammar. Though there is a major difference between discard sub-recognizers and terminal sub-recognizers: a discard sub-recognizer will never instanciate another discard sub-sub-recognizer. This mean that in the following:

  :discard    ::= whitespace
  :discard      ~ somethingelse
  whitespace    ~ /[\s]+/
  somethingelse ~ 'a string'

if a discard tentative is instancuated on grammar at level 0 using the symbol C<whitespace> of level 1, and if C<whitespace> of level 1 does not match, there will be no tentative for try to discard in level 1, even it is has a C<:discard> rule that is defined to be C<somethingelse>.

=head2 Streaming, character and binary modes

Everytime any recognizer need more data, a callback to userspace is triggered. This callback is set up in the top recognizer's option, and shared with any sub-recognizer. Its definition is:

  typedef short (*marpaESLIFReader_t)(void *userDatavp, char **inputcpp, size_t *inputlp, short *eofbp, short *characterStreambp, char **encodingOfEncodingsp, char **encodingsp, size_t *encodinglp);

where C<userDatavp> is an opaque pointer holding user's context. If this function return a true value, marpaESLIF expect the user to have filled in C<*inputcp>, C<*inputlp> and C<*eofbp> the location of the next buffer, its number of B<bytes>, and the eventual EOF information, respectively.

Mixing character streaming and binary streaming is possible, though it will be under the user responsibility to split the chunks of data accordingly. Usage of grammar I<events> will be helpful in such a case. It is possible to use characters streaming in a binary mode though, but then the grammar itself has to be instructed to B<not> work with characters.

When the user know it is a stream of characters, he is setting the C<*characterStreambp> to a true value, and can eventually give the encoding itself in C<*encodingsp>, that has C<*encodinglp> byte, and is itself encoded using the C<*encodingOfEncodingsp> charset (which have to be an ASCII thingy). It is perfectly legal to say you do not know the encoding by setting C<NULL>, C<NULL> and C<0> in these three pointers. Then marpaESLIF will guess about the charset for this chunk of data, although you should give enough bytes to have an accurate guess. Encoding of encoding information obey the same rule: you can set C<NULL> in C<*encodingOfEncodingsp>, though giving information in C<*encodingsp> and C<*encodinglp>.

Internally, all chunks of characters are converted to UTF-8. This guarantees three things:

=over

=item Validation of well-formed characters

=item uniform internal processing

=item native compatibility with the regular expression engine

=back

=head2 Terminals and Regular expression engine

As mentionned above, regular expression are totally handled using L<PCRE2|http://www.pcre.org/>. Therefore the syntax of regular expression is the PCRE2 syntax. It is obvious that a regular expression define an internal "terminal", and there are three ways to define such a terminal, all of them being converted to a regular expression:

=over

=item String

=item Character class

=item Regular expression

=back

Each of these three terminal types support eventual modifiers.

=over

=item String

A string is delimited expression in the grammar, where allowed start/and delimiters are C<''> and C<"">. When a string is recognized in the grammar, escaping is allowed using the backslash C<\> character, and only the start delimited or backslash itself can be escaped. Absolutely any other character is taken C<as is>, eventually internally escaped by marpaESLIF to remove its signification in PCRE2, when there is one. For example:

=over

=item 'Example'

is translated to the UTF-8 pattern C<Example>

=item '{Example}'

is translated to the UTF-8 pattern C<\{Example>

=item "{Example}"

is translated to the UTF-8 pattern C<\{Example>

=item '{Example[]\}'

will trigger an error because only C<'> or C<\> itself can be backslashed.

=item '{Example[]\\}'

is translated to the UTF-8 pattern C<\{Example\[]\\}>

=item 'Black Heart Suite Character: ♥'

is translated to the UTF-8 pattern C<Black Heart Suite Character: \x{2665}>

=back

A string is always scanned character per character by marpaESLIF, and an ASCII compatible pattern is generated, using \x{...} codepoint notation whenever this is an ASCII special character or a character outside of original ASCII 7-bits character set. So marpaESLIF know if there is need for unicode support or not in PCRE2 terminology (which is: any code point greater than 255, else byte matching is enough). This is important because PCRE2 yells if a pattern is using a large codepoint and if this internal PCRE2_UTF flag is not set accordingly.

The presence of this flag has an important consequence: if at least one string in the grammar implied the PCRE2_UTF flag, then the whole remaining chunk of data is translated and validated as an UTF-8 sequence of bytes. In such ca case, either the user input reader informed that this is stream of characters, then marpaESLIF prepared in advance the conversion/validation to UTF-8, either this is done lazily as soon as a match is attempted using a string requiring the PCRE2_UTF flag.

=item String modifiers

String modifiers must be appended directly after the end delimiter of the string. They are restricted to C<:i>, meaning that the match is caseless sensitive:

=over

=item 'Black Heart Suite Character: ♥':i

A dump of it in terms of PCRE2 (c.f. the API specification for dump facility) would show the C<PCRE2_CASELESS> flag:

  #      Pattern: Black Heart Suite Character: \x{2665}
  #        Flags: PCRE2_ANCHORED|PCRE2_CASELESS|PCRE2_UTF

You notice the presence of:

=over

=item C<PCRE2_ANCHORED>

Strings are always anchored at the point where match is attempted.

=item C<PCRE2_UTF>

This flag is automatically set when the scanning of the string that is in the grammar, done internally by marpaESLIF, reveal the need for it.

=back

=item 'Example':i

would give the following dump:

  #      Pattern: Example
  #        Flags: PCRE2_ANCHORED|PCRE2_CASELESS


=back

=item Character class

A character class is very closed to a regular expression (see later), except that it looks like a string, with start/end delimiters being C<[]>, and that the pattern is NOT scanned. marpaESLIF will lets PCRE2 eventually yell if there is a use of codepoints and if the internal PCRE2_UTF flag is not set.

=item Regular expression

=back

=head1 SEE ALSO

L<marpaESLIF_BNF|https://github.com/jddurand/c-marpaESLIF/tree/master/doc/BNF>, L<genericLogger|https://github.com/jddurand/c-genericLogger>, L<PCRE2|http://www.pcre.org/>
